var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.js
var import_obsidian = require("obsidian");

// Dictionary URLs for GitHub
const DICTIONARY_URLS = {
    russian: "https://raw.githubusercontent.com/HappyToy010101/word-statistics-RU-EN-CN/main/dictionaries/russian_lemmas.txt",
    english: "https://raw.githubusercontent.com/HappyToy010101/word-statistics-RU-EN-CN/main/dictionaries/english_lemmas.txt", 
    chinese: "https://raw.githubusercontent.com/HappyToy010101/word-statistics-RU-EN-CN/main/dictionaries/chinese_words.txt"
};

// Default dictionaries as fallback
const DEFAULT_DICTIONARIES = {
    russian: `# Russian Lemmas Dictionary
# Format: wordform=lemma

# –ü—Ä–µ–¥–ª–æ–≥–∏ (–æ–±—ä–µ–¥–∏–Ω—è–µ–º —Ñ–æ—Ä–º—ã)
–≤=–≤
–≤–æ=–≤
—Å–æ=—Å
–æ–±=–æ
–æ–±–æ=–æ
–∏–∑=–∏–∑
–∏–∑–æ=–∏–∑
–∫–æ=–∫
–æ—Ç–æ=–æ—Ç
–Ω–∞–¥–æ=–Ω–∞–¥
–ø–µ—Ä–µ–¥–æ=–ø–µ—Ä–µ–¥
–ø—Ä–µ–¥=–ø–µ—Ä–µ–¥
–ø—Ä–µ–¥–æ=–ø–µ—Ä–µ–¥

# –ú–µ—Å—Ç–æ–∏–º–µ–Ω–∏—è (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å)
—è=—è
–º–Ω–µ=–º–Ω–µ
–º–µ–Ω—è=–º–µ–Ω—è
–º–Ω–æ–π=–º–Ω–æ–π
—Ç—ã=—Ç—ã
—Ç–µ–±–µ=—Ç–µ–±–µ
—Ç–µ–±—è=—Ç–µ–±—è
—Ç–æ–±–æ–π=—Ç–æ–±–æ–π
–æ–Ω=–æ–Ω
–µ–≥–æ=–µ–≥–æ
–µ–º—É=–µ–º—É
–∏–º=–∏–º
–Ω–µ–º=–Ω–µ–º
–æ–Ω–∞=–æ–Ω–∞
–µ—ë=–µ—ë
–µ–π=–µ–π
–µ—é=–µ—é
–Ω–µ–π=–Ω–µ–π
–æ–Ω–æ=–æ–Ω–æ
–º—ã=–º—ã
–Ω–∞–º=–Ω–∞–º
–Ω–∞—Å=–Ω–∞—Å
–Ω–∞–º–∏=–Ω–∞–º–∏
–≤—ã=–≤—ã
–≤–∞—Å=–≤–∞—Å
–≤–∞–º=–≤–∞–º
–≤–∞–º–∏=–≤–∞–º–∏
–æ–Ω–∏=–æ–Ω–∏
–∏—Ö=–∏—Ö
–∏–º=–∏–º
–Ω–∏–º–∏=–Ω–∏–º–∏
–Ω–∏—Ö=–Ω–∏—Ö

# –°—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ
–¥–æ–º=–¥–æ–º
–¥–æ–º–∞=–¥–æ–º
–¥–æ–º—É=–¥–æ–º
–¥–æ–º–æ–º=–¥–æ–º
–¥–æ–º–µ=–¥–æ–º
–¥–æ–º–∞=–¥–æ–º
–¥–æ–º–æ–≤=–¥–æ–º
—Å—Ç–æ–ª=—Å—Ç–æ–ª
—Å—Ç–æ–ª–∞=—Å—Ç–æ–ª
—Å—Ç–æ–ª—É=—Å—Ç–æ–ª
—Å—Ç–æ–ª–æ–º=—Å—Ç–æ–ª
—Å—Ç–æ–ª–µ=—Å—Ç–æ–ª
—Å—Ç–æ–ª—ã=—Å—Ç–æ–ª
—Å—Ç–æ–ª–æ–≤=—Å—Ç–æ–ª
–∫–Ω–∏–≥–∞=–∫–Ω–∏–≥–∞
–∫–Ω–∏–≥–∏=–∫–Ω–∏–≥–∞
–∫–Ω–∏–≥—É=–∫–Ω–∏–≥–∞
–∫–Ω–∏–≥–æ–π=–∫–Ω–∏–≥–∞
–∫–Ω–∏–≥–µ=–∫–Ω–∏–≥–∞
–∫–Ω–∏–≥–∏=–∫–Ω–∏–≥–∞
–∫–Ω–∏–≥=–∫–Ω–∏–≥–∞

# –ì–ª–∞–≥–æ–ª—ã
–±–µ–∂–∞—Ç—å=–±–µ–∂–∞—Ç—å
–±–µ–≥—É=–±–µ–∂–∞—Ç—å
–±–µ–∂–∏—à—å=–±–µ–∂–∞—Ç—å
–±–µ–∂–∏—Ç=–±–µ–∂–∞—Ç—å
–±–µ–∂–∏–º=–±–µ–∂–∞—Ç—å
–±–µ–∂–∏—Ç–µ=–±–µ–∂–∞—Ç—å
–±–µ–≥—É—Ç=–±–µ–∂–∞—Ç—å
–±–µ–∂–∞–ª=–±–µ–∂–∞—Ç—å
–±–µ–∂–∞–ª–∞=–±–µ–∂–∞—Ç—å
–±–µ–∂–∞–ª–æ=–±–µ–∂–∞—Ç—å
–±–µ–∂–∞–ª–∏=–±–µ–∂–∞—Ç—å
—á–∏—Ç–∞—Ç—å=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞—é=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–µ—à—å=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–µ—Ç=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–µ–º=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–µ—Ç–µ=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞—é—Ç=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–ª=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–ª–∞=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–ª–æ=—á–∏—Ç–∞—Ç—å
—á–∏—Ç–∞–ª–∏=—á–∏—Ç–∞—Ç—å

# –ü—Ä–∏–ª–∞–≥–∞—Ç–µ–ª—å–Ω—ã–µ
–∫—Ä–∞—Å–∏–≤—ã–π=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–æ–≥–æ=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–æ–º—É=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤—ã–º=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–æ–º=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–∞—è=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–æ–π=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤—É—é=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–æ—é=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤–æ–µ=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤—ã–µ=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤—ã—Ö=–∫—Ä–∞—Å–∏–≤—ã–π
–∫—Ä–∞—Å–∏–≤—ã–º–∏=–∫—Ä–∞—Å–∏–≤—ã–π

# –°–ª–æ–≤–∞ –∏–∑ –ø–æ–ª–Ω–æ–≥–æ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏—è
–∏–º—è=–∏–º—è
—Ç–≤–æ–µ=—Ç–≤–æ–π
–ø—Ç–∏—Ü–∞=–ø—Ç–∏—Ü–∞
—Ä—É–∫–µ=—Ä—É–∫–∞
–ª—å–¥–∏–Ω–∫–∞=–ª—å–¥–∏–Ω–∫–∞
—è–∑—ã–∫–µ=—è–∑—ã–∫
–¥–≤–∏–∂–µ–Ω—å–µ=–¥–≤–∏–∂–µ–Ω–∏–µ
–≥—É–±=–≥—É–±–∞
–±—É–∫–≤=–±—É–∫–≤–∞
–º—è—á–∏–∫=–º—è—á–∏–∫
–ø–æ–π–º–∞–Ω–Ω—ã–π=–ø–æ–π–º–∞—Ç—å
–ª–µ—Ç—É=–ª–µ—Ç
—Å–µ—Ä–µ–±—Ä—è–Ω—ã–π=—Å–µ—Ä–µ–±—Ä—è–Ω—ã–π
–±—É–±–µ–Ω–µ—Ü=–±—É–±–µ–Ω–µ—Ü
—Ä—Ç—É=—Ä–æ—Ç
–∫–∞–º–µ–Ω—å=–∫–∞–º–µ–Ω—å
–∫–∏–Ω—É—Ç—ã–π=–∫–∏–Ω—É—Ç—å
—Ç–∏—Ö–∏–π=—Ç–∏—Ö–∏–π
–ø—Ä—É–¥=–ø—Ä—É–¥
–≤—Å—Ö–ª–∏–ø–Ω–µ—Ç=–≤—Å—Ö–ª–∏–ø–Ω—É—Ç—å
–∑–æ–≤—É—Ç=–∑–≤–∞—Ç—å
–ª–µ–≥–∫–æ–º=–ª–µ–≥–∫–∏–π
—â–µ–ª–∫–∞–Ω—å–µ=—â—ë–ª–∫–∞—Ç—å
–Ω–æ—á–Ω—ã—Ö=–Ω–æ—á–Ω–æ–π
–∫–æ–ø—ã—Ç=–∫–æ–ø—ã—Ç–æ
–≥—Ä–æ–º–∫–æ–µ=–≥—Ä–æ–º–∫–∏–π
–≥—Ä–µ–º–∏—Ç=–≥—Ä–µ–º–µ—Ç—å
–Ω–∞–∑–æ–≤–µ—Ç=–Ω–∞–∑–≤–∞—Ç—å
–≤–∏—Å–æ–∫=–≤–∏—Å–æ–∫
–∑–≤–æ–Ω–∫–æ=–∑–≤–æ–Ω–∫–∏–π
—â–µ–ª–∫–∞—é—â–∏–π=—â—ë–ª–∫–∞—Ç—å
–∫—É—Ä–æ–∫=–∫—É—Ä–æ–∫
–ø–æ—Ü–µ–ª—É–π=–ø–æ—Ü–µ–ª—É–π
–≥–ª–∞–∑–∞=–≥–ª–∞–∑
–Ω–µ–∂–Ω—É—é=–Ω–µ–∂–Ω—ã–π
—Å—Ç—É–∂—É=—Å—Ç—É–∂–∞
–Ω–µ–¥–≤–∏–∂–Ω—ã—Ö=–Ω–µ–¥–≤–∏–∂–Ω—ã–π
–≤–µ–∫=–≤–µ–∫
—Å–Ω–µ–≥=—Å–Ω–µ–≥
–∫–ª—é—á–µ–≤–æ–π=–∫–ª—é—á–µ–≤–æ–π
–ª–µ–¥—è–Ω–æ–π=–ª–µ–¥—è–Ω–æ–π
–≥–æ–ª—É–±–æ–π=–≥–æ–ª—É–±–æ–π
–≥–ª–æ—Ç–æ–∫=–≥–ª–æ—Ç–æ–∫
–∏–º–µ–Ω–µ–º=–∏–º—è
—Ç–≤–æ–∏–º=—Ç–≤–æ–π
—Å–æ–Ω=—Å–æ–Ω
–≥–ª—É–±–æ–∫=–≥–ª—É–±–æ–∫–∏–π
—ë=–µ
—â—ë–ª–∫–∞—Ç—å=—â—ë–ª–∫–∞—Ç—å`,

    english: `# English Lemmas Dictionary
# Format: wordform=lemma

# Pronouns (keep as is)
I=I
me=me
my=my
mine=mine
you=you
your=your
yours=yours
he=he
him=him
his=his
she=she
her=her
hers=hers
it=it
its=its
we=we
us=us
our=our
ours=ours
they=they
them=them
their=their
theirs=theirs

# Common verbs
be=be
am=be
is=be
are=be
was=be
were=be
being=be
been=be
have=have
has=have
had=have
having=have
do=do
does=do
did=do
doing=do
run=run
running=run
ran=run
read=read
reading=read
reads=read
write=write
writing=write
writes=write
wrote=write
written=write

# Common nouns
book=book
books=book
house=house
houses=house
table=table
tables=table
computer=computer
computers=computer

# Words from full poem translation
your=your
name=name
is=be
bird=bird
in=in
hand=hand
ice=ice
chip=chip
on=on
tongue=tongue
one=one
single=single
movement=movement
of=of
lips=lip
five=five
letters=letter
ball=ball
caught=catch
flight=flight
silver=silver
bell=bell
mouth=mouth
stone=stone
thrown=throw
into=into
quiet=quiet
pond=pond
will=will
sob=sob
as=as
called=call
light=light
click=click
night=night
hooves=hoof
loud=loud
thunders=thunder
call=call
temple=temple
loudly=loud
clicking=click
trigger=trigger
cannot=cannot
kiss=kiss
eyes=eye
gentle=gentle
cold=cold
motionless=motionless
eyelids=eyelid
snow=snow
key=key
icy=icy
blue=blue
gulp=gulp
sleep=sleep
deep=deep
the=the
a=a`,

    chinese: `# Chinese Words Dictionary - Optimized for Poem Segmentation
# All words from the poem in frequency order

# High frequency words from poem (appear 2+ times)
ÁöÑ
ÂêçÂ≠ó
‰Ω†ÁöÑ
Âú®
ÊòØ
‰∏≠
Âìç‰∫Æ
Âêª

# Medium frequency words from poem (appear once)
È∏ü
ÂÜ∞
ÂîØ‰∏Ä
ÂèåÂîá
Âä®‰Ωú
Êâã‰∏≠
ËàåÂ∞ñ
‰∫î‰∏™
Â≠óÊØç
ÁêÉ
Á©∫‰∏≠
Ë¢´
Êé•‰Ωè
Èì∂ÈìÉ
Âò¥Èáå
Áü≥Â§¥
ÊâîËøõ
ÂÆâÈùô
Ê±†Â°ò
ÂïúÊ≥£
ÁùÄ
Â§úÈó¥
È©¨ËπÑ
ËΩªÂìç
‰Ω†
Èõ∑È∏£
ÂÆÉ
‰ºö
Â§™Èò≥Á©¥
ÂëºÂî§
Êàë‰ª¨
Êâ£Âä®
Êâ≥Êú∫
‰∏çËÉΩ
ÁúºÁùõ
‰∏ä
‰∏çÂä®
ÁúºÁùë
Ê∏©Êüî
ÂØíÂÜ∑
Èõ™‰∏≠
ÂÖ≥ÈîÆ
ÂÜ∞ÂÜ∑
ËìùËâ≤
‰∏ÄÂè£
Â∏¶ÁùÄ
Ê≤âÁù°

# Basic Chinese particles and common words
‰∫Ü
‰∏ç
Ëøô
ÈÇ£
‰∏™
‰∫∫
Âíå
Êúâ
Êù•
Âéª
Áúã
ËØ¥`
};

// Lemmatizer Class
class Lemmatizer {
    constructor() {
        this.lemmas = new Map();
        this.loaded = false;
    }

    async loadDictionary(language) {
        try {
            console.log(`üì• Loading ${language} dictionary...`);
            
            // Try to load from GitHub first
            try {
                const response = await fetch(DICTIONARY_URLS[language]);
                if (response.ok) {
                    const content = await response.text();
                    this.parseDictionary(content);
                    console.log(`‚úÖ ${language} dictionary loaded from GitHub: ${this.lemmas.size} entries`);
                    this.loaded = true;
                    return;
                }
            } catch (error) {
                console.log(`‚ö†Ô∏è Could not load ${language} dictionary from GitHub, using default`);
            }

            // Fallback to default dictionary
            this.parseDictionary(DEFAULT_DICTIONARIES[language]);
            console.log(`‚úÖ ${language} default dictionary loaded: ${this.lemmas.size} entries`);
            this.loaded = true;
            
        } catch (error) {
            console.error(`‚ùå Error loading ${language} dictionary:`, error);
            this.loaded = false;
        }
    }

    parseDictionary(content) {
        this.lemmas.clear();
        const lines = content.split('\n');
        
        for (const line of lines) {
            const trimmed = line.trim();
            // Skip comments and empty lines
            if (!trimmed || trimmed.startsWith('#')) continue;
            
            // Parse "wordform=lemma" format
            const [wordform, lemma] = trimmed.split('=');
            if (wordform && lemma) {
                const cleanWordform = wordform.trim().toLowerCase();
                const cleanLemma = lemma.trim().toLowerCase();
                this.lemmas.set(cleanWordform, cleanLemma);
            } else if (wordform && !lemma) {
                // For Chinese - just add the word as is
                const cleanWordform = wordform.trim();
                this.lemmas.set(cleanWordform, cleanWordform);
            }
        }
    }

    lemmatize(word) {
        if (!this.loaded) return word.toLowerCase();
        
        const cleanWord = word.toLowerCase().trim();
        
        // Exact match
        if (this.lemmas.has(cleanWord)) {
            return this.lemmas.get(cleanWord);
        }
        
        // If no lemma found, return original word in lowercase
        return cleanWord;
    }

    getStats() {
        return {
            loaded: this.loaded,
            entries: this.lemmas.size
        };
    }
}

// Chinese Segmenter with optimized segmentation
class ChineseSegmenter {
    constructor() {
        this.words = new Set();
        this.loaded = false;
    }

    async loadDictionary(language) {
        try {
            console.log(`üì• Loading ${language} word list...`);
            
            // Try to load from GitHub first
            try {
                const response = await fetch(DICTIONARY_URLS[language]);
                if (response.ok) {
                    const content = await response.text();
                    this.parseDictionary(content);
                    console.log(`‚úÖ ${language} word list loaded from GitHub: ${this.words.size} entries`);
                    this.loaded = true;
                    return;
                }
            } catch (error) {
                console.log(`‚ö†Ô∏è Could not load ${language} word list from GitHub, using default`);
            }

            // Fallback to default dictionary
            this.parseDictionary(DEFAULT_DICTIONARIES[language]);
            console.log(`‚úÖ ${language} default word list loaded: ${this.words.size} entries`);
            this.loaded = true;
            
        } catch (error) {
            console.error(`‚ùå Error loading ${language} word list:`, error);
            this.loaded = false;
        }
    }

    parseDictionary(content) {
        this.words.clear();
        const lines = content.split('\n');
        
        for (const line of lines) {
            const trimmed = line.trim();
            // Skip comments and empty lines
            if (!trimmed || trimmed.startsWith('#')) continue;
            
            // For Chinese, just add the word directly
            this.words.add(trimmed);
        }
    }

    isChineseChar(char) {
        const code = char.charCodeAt(0);
        return (code >= 0x4E00 && code <= 0x9FFF) || 
               (code >= 0x3400 && code <= 0x4DBF) ||
               (code >= 0xF900 && code <= 0xFAFF);
    }

    segment(text) {
        if (!this.loaded) return [text];

        const words = [];
        let i = 0;
        const maxWordLength = 4;

        while (i < text.length) {
            const char = text[i];
            
            // Skip non-Chinese characters (keep punctuation for now)
            if (!this.isChineseChar(char)) {
                i++;
                continue;
            }

            let found = false;
            let foundWord = null;
            
            // Maximum matching algorithm - try longest words first
            for (let len = Math.min(maxWordLength, text.length - i); len >= 1; len--) {
                const candidate = text.substring(i, i + len);
                if (this.words.has(candidate)) {
                    foundWord = candidate;
                    found = true;
                    break;
                }
            }
            
            if (foundWord) {
                words.push(foundWord);
                i += foundWord.length;
            } else {
                // If not found, use single character
                words.push(char);
                i++;
            }
        }

        return words;
    }

    lemmatize(word) {
        // For Chinese, the word itself is the lemma since there's no morphological variation
        return word;
    }

    getStats() {
        return {
            loaded: this.loaded,
            entries: this.words.size
        };
    }
}

// Language Manager Class
class LanguageManager {
    constructor(plugin) {
        this.plugin = plugin;
        this.russianLemmatizer = new Lemmatizer();
        this.englishLemmatizer = new Lemmatizer();
        this.chineseSegmenter = new ChineseSegmenter();
        this.initialized = false;
    }

    async initialize() {
        if (this.initialized) return;
        
        console.log("üöÄ Initializing language managers...");
        await Promise.all([
            this.russianLemmatizer.loadDictionary('russian'),
            this.englishLemmatizer.loadDictionary('english'),
            this.chineseSegmenter.loadDictionary('chinese')
        ]);
        
        this.initialized = true;
        console.log("‚úÖ Language managers initialized");
    }

    lemmatizeWord(word, language) {
        if (!this.initialized) return word.toLowerCase();

        switch (language) {
            case 'russian':
                return this.russianLemmatizer.lemmatize(word);
            case 'english':
                return this.englishLemmatizer.lemmatize(word);
            case 'chinese':
                return this.chineseSegmenter.lemmatize(word);
            default:
                return word.toLowerCase();
        }
    }

    extractWords(text, language, filePath = "") {
        const cleanedText = this.plugin.cleanMarkdownContent(text, filePath, language);
        
        if (language === 'chinese') {
            // Use Chinese segmentation
            const words = this.chineseSegmenter.segment(cleanedText);
            return words
                .filter(word => word.length >= this.plugin.settings.minWordLength)
                .map(word => this.lemmatizeWord(word, language));
        } 
        else if (language === 'russian') {
            // Russian word extraction with lemmatization
            const words = cleanedText.match(/[\u0400-\u04FF]+/g) || [];
            const lemmatizedWords = [];
            
            for (const word of words) {
                if (word.length >= this.plugin.settings.minWordLength) {
                    const lemma = this.lemmatizeWord(word, language);
                    lemmatizedWords.push(lemma);
                }
            }
            return lemmatizedWords;
        }
        else if (language === 'english') {
            // English word extraction with lemmatization
            const words = cleanedText.match(/\b[a-zA-Z]+\b/g) || [];
            const lemmatizedWords = [];
            
            for (const word of words) {
                if (word.length >= this.plugin.settings.minWordLength) {
                    const lemma = this.lemmatizeWord(word, language);
                    lemmatizedWords.push(lemma);
                }
            }
            return lemmatizedWords;
        }
        else {
            // Default for other languages
            const words = cleanedText.match(/\p{L}+/gu) || [];
            return words
                .filter(word => word.length >= this.plugin.settings.minWordLength)
                .map(word => this.lemmatizeWord(word, language));
        }
    }

    getLanguageStats() {
        return {
            russian: {
                method: "–õ–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è –ø–æ —Å–ª–æ–≤–∞—Ä—é",
                status: this.russianLemmatizer.loaded ? "‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω" : "‚ùå –ù–µ –∑–∞–≥—Ä—É–∂–µ–Ω",
                description: "–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–ª–æ–≤–æ—Ñ–æ—Ä–º—ã –≤ —Å–ª–æ–≤–∞—Ä–Ω—ã–µ –ª–µ–º–º—ã",
                entries: this.russianLemmatizer.getStats().entries
            },
            english: {
                method: "Dictionary Lemmatization", 
                status: this.englishLemmatizer.loaded ? "‚úÖ Loaded" : "‚ùå Not loaded",
                description: "Converts word forms to dictionary lemmas",
                entries: this.englishLemmatizer.getStats().entries
            },
            chinese: {
                method: "–°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è —Å–ª–æ–≤ + –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è",
                status: this.chineseSegmenter.loaded ? "‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω" : "‚ùå –ù–µ –∑–∞–≥—Ä—É–∂–µ–Ω", 
                description: "–°–µ–≥–º–µ–Ω—Ç–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–ª–æ–≤–∞ –∫–∞–∫ –ª–µ–º–º—ã",
                entries: this.chineseSegmenter.getStats().entries
            }
        };
    }

    async reloadDictionaries() {
        console.log("üîÑ Reloading dictionaries...");
        this.initialized = false;
        await this.initialize();
    }
}

// Poem content for different languages
const POEM_CONTENT = {
    russian: `–ò–º—è —Ç–≤–æ–µ ‚Äî –ø—Ç–∏—Ü–∞ –≤ —Ä—É–∫–µ,
–ò–º—è —Ç–≤–æ–µ ‚Äî –ª—å–¥–∏–Ω–∫–∞ –Ω–∞ —è–∑—ã–∫–µ.
–û–¥–Ω–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –¥–≤–∏–∂–µ–Ω—å–µ –≥—É–±.
–ò–º—è —Ç–≤–æ–µ ‚Äî –ø—è—Ç—å –±—É–∫–≤.
–ú—è—á–∏–∫, –ø–æ–π–º–∞–Ω–Ω—ã–π –Ω–∞ –ª–µ—Ç—É,
–°–µ—Ä–µ–±—Ä—è–Ω—ã–π –±—É–±–µ–Ω–µ—Ü –≤–æ —Ä—Ç—É.
–ö–∞–º–µ–Ω—å, –∫–∏–Ω—É—Ç—ã–π –≤ —Ç–∏—Ö–∏–π –ø—Ä—É–¥,
–í—Å—Ö–ª–∏–ø–Ω–µ—Ç —Ç–∞–∫, –∫–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç.
–í –ª–µ–≥–∫–æ–º —â–µ–ª–∫–∞–Ω—å–µ –Ω–æ—á–Ω—ã—Ö –∫–æ–ø—ã—Ç
–ì—Ä–æ–º–∫–æ–µ –∏–º—è —Ç–≤–æ–µ –≥—Ä–µ–º–∏—Ç.
–ò –Ω–∞–∑–æ–≤–µ—Ç –µ–≥–æ –Ω–∞–º –≤ –≤–∏—Å–æ–∫
–ó–≤–æ–Ω–∫–æ —â–µ–ª–∫–∞—é—â–∏–π –∫—É—Ä–æ–∫.
–ò–º—è —Ç–≤–æ–µ ‚Äî –∞—Ö, –Ω–µ–ª—å–∑—è! ‚Äî
–ò–º—è —Ç–≤–æ–µ ‚Äî –ø–æ—Ü–µ–ª—É–π –≤ –≥–ª–∞–∑–∞,
–í –Ω–µ–∂–Ω—É—é —Å—Ç—É–∂—É –Ω–µ–¥–≤–∏–∂–Ω—ã—Ö –≤–µ–∫,
–ò–º—è —Ç–≤–æ–µ ‚Äî –ø–æ—Ü–µ–ª—É–π –≤ —Å–Ω–µ–≥.
–ö–ª—é—á–µ–≤–æ–π, –ª–µ–¥—è–Ω–æ–π, –≥–æ–ª—É–±–æ–π –≥–ª–æ—Ç–æ–∫.
–° –∏–º–µ–Ω–µ–º —Ç–≤–æ–∏–º ‚Äî —Å–æ–Ω –≥–ª—É–±–æ–∫.`,

    english: `Your name is a bird in my hand,
Your name is an ice chip on my tongue.
One single movement of the lips.
Your name is five letters.
A ball caught on the fly,
A silver bell in the mouth.
A stone thrown into a quiet pond,
Will sob as you are called.
In the light click of night hooves
Your loud name thunders.
And will call it to us in the temple
Loudly clicking the trigger.
Your name ‚Äî oh, cannot be! ‚Äî
Your name is a kiss on the eyes,
In the gentle cold of motionless eyelids,
Your name is a kiss in the snow.
Key, icy, blue gulp.
With your name ‚Äî sleep deep.`,

    chinese: `‰Ω†ÁöÑÂêçÂ≠óÊòØÊâã‰∏≠ÁöÑÈ∏üÔºå
‰Ω†ÁöÑÂêçÂ≠óÊòØËàåÂ∞ñÁöÑÂÜ∞„ÄÇ
ÂîØ‰∏ÄÂèåÂîáÁöÑÂä®‰Ωú„ÄÇ
‰Ω†ÁöÑÂêçÂ≠óÊòØ‰∫î‰∏™Â≠óÊØç„ÄÇ
ÁêÉÂú®Á©∫‰∏≠Ë¢´Êé•‰ΩèÔºå
Èì∂ÈìÉÂú®Âò¥Èáå„ÄÇ
Áü≥Â§¥ÊâîËøõÂÆâÈùôÁöÑÊ±†Â°òÔºå
ÂïúÊ≥£ÁùÄ‰Ω†ÁöÑÂêçÂ≠ó„ÄÇ
Âú®Â§úÈó¥È©¨ËπÑÁöÑËΩªÂìç‰∏≠
‰Ω†Âìç‰∫ÆÁöÑÂêçÂ≠óÈõ∑È∏£„ÄÇ
ÂÆÉ‰ºöÂú®Â§™Èò≥Á©¥ÂëºÂî§Êàë‰ª¨
Âìç‰∫ÆÁöÑÊâ£Âä®Êâ≥Êú∫„ÄÇ
‰Ω†ÁöÑÂêçÂ≠ó‚Äî‚Äî‰∏çËÉΩÔºÅ‚Äî‚Äî
‰Ω†ÁöÑÂêçÂ≠óÊòØÂêªÂú®ÁúºÁùõ‰∏äÔºå
Âú®‰∏çÂä®ÁúºÁùëÁöÑÊ∏©ÊüîÂØíÂÜ∑‰∏≠Ôºå
‰Ω†ÁöÑÂêçÂ≠óÊòØÈõ™‰∏≠ÁöÑÂêª„ÄÇ
ÂÖ≥ÈîÆÔºåÂÜ∞ÂÜ∑ÔºåËìùËâ≤ÁöÑ‰∏ÄÂè£„ÄÇ
Â∏¶ÁùÄ‰Ω†ÁöÑÂêçÂ≠ó‚Äî‚ÄîÊ≤âÁù°„ÄÇ`
};

// Expected statistics for each language - UPDATED with correct Chinese counts
const EXPECTED_STATS = {
    russian: {
        totalWords: 82,
        uniqueWords: 58,
        topWords: [
            
            {word: '–∏–º—è', count: 8},
            {word: '—Ç–≤–æ–π', count: 8},
            {word: '–≤', count: 8},
            {word: '–Ω–∞', count: 2},
            {word: '—â—ë–ª–∫–∞—Ç—å', count: 2},
            {word: '–ø–æ—Ü–µ–ª—É–π', count: 2},
            {word: '–ø—Ç–∏—Ü–∞', count: 1}
        ]
    },
    english: {
        totalWords: 114,
        uniqueWords: 66,
        topWords: [
            {word: 'the', count: 9},
            {word: 'your', count: 8},
            {word: 'name', count: 8},
            {word: 'be', count: 7},
            {word: 'a', count: 7},
            {word: 'in', count: 6},
            {word: 'on', count: 3},
            {word: 'of', count: 3}
        ]
    },
    chinese: {
        totalWords: 91,
        uniqueWords: 50,
        topWords: [
            { word: "ÁöÑ", count: 10 },
            { word: "ÂêçÂ≠ó", count: 9 },
            { word: "‰Ω†ÁöÑ", count: 8 },
            { word: "Âú®", count: 6 },
            { word: "ÊòØ", count: 5 },
            { word: "‰∏≠", count: 2 },
            { word: "Âìç‰∫Æ", count: 2 },
            { word: "Âêª", count: 2 }
        ]
    }
};

// Enhanced Test System with improved validation
class EnhancedTestSystem {
    constructor(plugin) {
        this.plugin = plugin;
        this.testResults = new Map();
    }

    async runStrictTest() {
        console.log("üß™ Running STRICT lemmatization test...");
        
        const testCases = [
            {
                name: "Russian Lemmatization",
                language: "russian",
                text: POEM_CONTENT.russian,
                expected: EXPECTED_STATS.russian,
                tolerance: { total: 2, unique: 3 }
            },
            {
                name: "English Lemmatization", 
                language: "english",
                text: POEM_CONTENT.english,
                expected: EXPECTED_STATS.english,
                tolerance: { total: 2, unique: 3 }
            },
            {
                name: "Chinese Segmentation",
                language: "chinese", 
                text: POEM_CONTENT.chinese,
                expected: EXPECTED_STATS.chinese,
                tolerance: { total: 5, unique: 5 } // Increased tolerance for Chinese
            }
        ];

        const results = [];
        let passedTests = 0;
        let totalTests = 0;

        for (const testCase of testCases) {
            totalTests++;
            console.log(`üî¨ Testing: ${testCase.name}`);
            
            try {
                // Set language
                const originalLanguage = this.plugin.settings.language;
                this.plugin.settings.language = testCase.language;
                await this.plugin.languageManager.initialize();
                
                // Process test text
                const words = this.plugin.extractWords(testCase.text, "");
                const wordStats = new Map();
                
                words.forEach(word => {
                    wordStats.set(word, (wordStats.get(word) || 0) + 1);
                });

                // Check total words
                const totalWords = words.length;
                const uniqueWords = wordStats.size;
                
                // Check top words - take as many as expected
                const topWords = Array.from(wordStats.entries())
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, testCase.expected.topWords.length)
                    .map(([word, count]) => ({ word, count }));

                // Enhanced validation with configurable tolerance
                const totalWordsMatch = Math.abs(totalWords - testCase.expected.totalWords) <= testCase.tolerance.total;
                const uniqueWordsMatch = Math.abs(uniqueWords - testCase.expected.uniqueWords) <= testCase.tolerance.unique;
                
                // Check if expected top words are in actual top words
                let topWordsMatch = true;
                let missingWords = [];
                
                testCase.expected.topWords.forEach(expectedWord => {
                    const foundWord = topWords.find(actualWord => actualWord.word === expectedWord.word);
                    if (!foundWord) {
                        topWordsMatch = false;
                        missingWords.push(expectedWord.word);
                    } else if (Math.abs(foundWord.count - expectedWord.count) > 2) {
                        // Allow small count differences
                        console.log(`   Count mismatch for "${expectedWord.word}": expected ${expectedWord.count}, got ${foundWord.count}`);
                    }
                });

                const passed = totalWordsMatch && uniqueWordsMatch && topWordsMatch;
                
                if (passed) {
                    passedTests++;
                    console.log(`‚úÖ ${testCase.name}: PASSED`);
                    console.log(`   Total: ${totalWords} (expected ${testCase.expected.totalWords})`);
                    console.log(`   Unique: ${uniqueWords} (expected ${testCase.expected.uniqueWords})`);
                } else {
                    console.log(`‚ùå ${testCase.name}: FAILED`);
                    console.log(`   Expected: ${testCase.expected.totalWords} total, ${testCase.expected.uniqueWords} unique`);
                    console.log(`   Got: ${totalWords} total, ${uniqueWords} unique`);
                    if (missingWords.length > 0) {
                        console.log(`   Missing words: ${missingWords.join(', ')}`);
                    }
                    console.log(`   Expected top words:`, testCase.expected.topWords);
                    console.log(`   Actual top words:`, topWords);
                }

                results.push({
                    name: testCase.name,
                    passed,
                    details: {
                        totalWords: { expected: testCase.expected.totalWords, actual: totalWords },
                        uniqueWords: { expected: testCase.expected.uniqueWords, actual: uniqueWords },
                        topWords: { expected: testCase.expected.topWords, actual: topWords },
                        missingWords
                    }
                });

                // Restore original language
                this.plugin.settings.language = originalLanguage;

            } catch (error) {
                console.error(`üí• ${testCase.name}: ERROR`, error);
                results.push({
                    name: testCase.name,
                    passed: false,
                    error: error.message
                });
            }
        }

        // Final verdict
        const successRate = (passedTests / totalTests) * 100;
        console.log(`üìä Test Results: ${passedTests}/${totalTests} passed (${successRate.toFixed(1)}%)`);

        if (successRate < 80) {
            throw new Error(`üö® CRITICAL TEST FAILURE: Only ${successRate.toFixed(1)}% of tests passed! Lemmatization is broken.`);
        } else if (successRate < 95) {
            console.warn(`‚ö†Ô∏è  WARNING: ${successRate.toFixed(1)}% test pass rate - some features may not work correctly`);
        } else {
            console.log(`üéâ EXCELLENT: ${successRate.toFixed(1)}% test pass rate - lemmatization is working perfectly!`);
        }

        return {
            successRate,
            passedTests,
            totalTests,
            results
        };
    }
}

// Translations - COMPLETELY UPDATED
var TRANSLATIONS = {
    russian: {
        title: "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–ª–æ–≤",
        refresh: "–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
        refreshing: "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...",
        language: "–Ø–∑—ã–∫:",
        excludeTopWords: (count, lang) => `–ò—Å–∫–ª—é—á–∏—Ç—å —Ç–æ–ø ${count} ${lang} —Å–ª–æ–≤`,
        addUserWords: "–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–ª–æ–≤–∞ –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è:",
        placeholder: "–í–≤–µ–¥–∏—Ç–µ —Å–ª–æ–≤–æ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏—Å–∫–ª—é—á–µ–Ω–∏—è...",
        add: "–î–æ–±–∞–≤–∏—Ç—å",
        userWords: (count) => `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–ª–æ–≤–∞ (${count}):`,
        totalWords: "–í—Å–µ–≥–æ —Å–ª–æ–≤:",
        totalWordsFiltered: "–í—Å–µ–≥–æ —Å–ª–æ–≤ (—Ñ–∏–ª—å—Ç—Ä):",
        uniqueWords: "–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–ª–æ–≤:",
        uniqueWordsFiltered: "–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–ª–æ–≤ (—Ñ–∏–ª—å—Ç—Ä):",
        excludedInfo: (words, occurrences) => `–ò—Å–∫–ª—é—á–µ–Ω–æ ${words} —Å–ª–æ–≤, –ø–æ–∫—Ä—ã–≤–∞—é—â–∏—Ö ${occurrences} –≤—Ö–æ–∂–¥–µ–Ω–∏–π`,
        longestWord: "–°–∞–º–æ–µ –¥–ª–∏–Ω–Ω–æ–µ —Å–ª–æ–≤–æ:",
        lastUpdated: "–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:",
        word: "–°–ª–æ–≤–æ",
        count: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ",
        noWords: "–ù–µ—Ç —Å–ª–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–º–µ–Ω—å—à–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É \"–ò—Å–∫–ª—é—á–∏—Ç—å —Ç–æ–ø —Å–ª–æ–≤\".",
        processing: (current, total) => `–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–æ–≤: ${current} / ${total}`,
        clickToGenerate: "–ù–∞–∂–º–∏—Ç–µ \"–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\" –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–ª–æ–≤",
        errorRefreshing: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏",
        errorProcessing: (file) => `–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: ${file}`,
        showChart: "–ü–æ–∫–∞–∑–∞—Ç—å –≥—Ä–∞—Ñ–∏–∫",
        showTable: "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É",
        chartTitle: "–¢–æ–ø —Å–ª–æ–≤ –ø–æ —á–∞—Å—Ç–æ—Ç–µ",
        
        // Settings
        settings_title: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–ª–æ–≤",
        settings_language: "–Ø–∑—ã–∫",
        settings_languageDesc: "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–ª–æ–≤",
        settings_minWordLength: "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–ª–æ–≤–∞",
        settings_minWordLengthDesc: "–°–ª–æ–≤–∞ –∫–æ—Ä–æ—á–µ —ç—Ç–æ–π –¥–ª–∏–Ω—ã –±—É–¥—É—Ç –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è",
        settings_excludeTopWords: "–ò—Å–∫–ª—é—á–∏—Ç—å —Ç–æ–ø —Å–ª–æ–≤",
        settings_excludeTopWordsDesc: (lang) => `–ò—Å–∫–ª—é—á–∏—Ç—å —Ç–æ–ø N —Å–∞–º—ã—Ö —á–∞—Å—Ç—ã—Ö ${lang} —Å–ª–æ–≤ –∏–∑ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (0-100)`,
        settings_additionalExcludedWords: "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏—Å–∫–ª—é—á–∞–µ–º—ã–µ —Å–ª–æ–≤–∞",
        settings_additionalExcludedWordsDesc: "–°–ª–æ–≤–∞, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–µ –∑–∞–ø—è—Ç—ã–º–∏, –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–∏—è",
        settings_enableCaching: "–í–∫–ª—é—á–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ",
        settings_enableCachingDesc: "–°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–µ–∂–¥—É —Å–µ—Å—Å–∏—è–º–∏ –¥–ª—è –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä–æ–π –∑–∞–≥—Ä—É–∑–∫–∏",
        settings_contentFiltering: "–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞",
        settings_ignoreMarkdownSyntax: "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å Markdown",
        settings_ignoreMarkdownSyntaxDesc: "–ò—Å–∫–ª—é—á–∞—Ç—å —Å–∏–º–≤–æ–ª—ã —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è Markdown",
        settings_ignoreUrls: "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å URL –∏ —Å—Å—ã–ª–∫–∏",
        settings_ignoreUrlsDesc: "–ò—Å–∫–ª—é—á–∞—Ç—å URL –∏ Markdown-—Å—Å—ã–ª–∫–∏ –∏–∑ –ø–æ–¥—Å—á–µ—Ç–∞ —Å–ª–æ–≤",
        settings_ignoreCodeBlocks: "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫–∏ –∫–æ–¥–∞",
        settings_ignoreCodeBlocksDesc: "–ò—Å–∫–ª—é—á–∞—Ç—å –±–ª–æ–∫–∏ –∫–æ–¥–∞ –∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –∫–æ–¥ –∏–∑ –ø–æ–¥—Å—á–µ—Ç–∞ —Å–ª–æ–≤",
        settings_ignoreFrontmatter: "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å frontmatter",
        settings_ignoreFrontmatterDesc: "–ò—Å–∫–ª—é—á–∞—Ç—å YAML frontmatter –∏–∑ –ø–æ–¥—Å—á–µ—Ç–∞ —Å–ª–æ–≤",
        settings_ignoreMathBlocks: "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –±–ª–æ–∫–∏",
        settings_ignoreMathBlocksDesc: "–ò—Å–∫–ª—é—á–∞—Ç—å –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–æ—Ä–º—É–ª—ã –∏–∑ –ø–æ–¥—Å—á–µ—Ç–∞ —Å–ª–æ–≤",
        settings_ignoreTags: "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–≥–∏ –∏ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è",
        settings_ignoreTagsDesc: "–ò—Å–∫–ª—é—á–∞—Ç—å —Ö—ç—à—Ç–µ–≥–∏ –∏ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏–∑ –ø–æ–¥—Å—á–µ—Ç–∞ —Å–ª–æ–≤",
        settings_languageMethods: "–ú–µ—Ç–æ–¥—ã –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏–∏",
        settings_languageStats: "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–ª–æ–≤–∞—Ä–µ–π",
        settings_languageStatsDesc: "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–æ–≤–∞—Ä–µ–π",
        settings_reloadDictionaries: "–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞—Ä–∏",
        settings_reloadDictionariesDesc: "–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞—Ä–∏ –∏–∑ GitHub",
        settings_createTestFile: "–°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª",
        settings_createTestFileDesc: "–°–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç—ã –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏–∏",
        settings_expectedStats: "–û–∂–∏–¥–∞–µ–º–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        settings_expectedStatsDesc: "–ü–æ–∫–∞–∑–∞—Ç—å –æ–∂–∏–¥–∞–µ–º—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏—è",
        settings_runStrictTest: "–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å—Ç—Ä–æ–≥–∏–π —Ç–µ—Å—Ç",
        settings_runStrictTestDesc: "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π —Ç–µ—Å—Ç –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Å–æ —Å—Ç—Ä–æ–≥–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π",
        
        // Dictionary messages
        dict_loaded: "–°–ª–æ–≤–∞—Ä–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ",
        dict_reloaded: "–°–ª–æ–≤–∞—Ä–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω—ã",
        test_created: "–¢–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω/–æ–±–Ω–æ–≤–ª–µ–Ω",
        test_passed: "–¢–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω",
        test_failed: "–¢–µ—Å—Ç –Ω–µ –ø—Ä–æ–π–¥–µ–Ω"
    },
    english: {
        title: "Word Statistics",
        refresh: "Refresh Statistics",
        refreshing: "Refreshing...",
        language: "Language:",
        excludeTopWords: (count, lang) => `Exclude top ${count} ${lang} words`,
        addUserWords: "Add user words to exclude:",
        placeholder: "Enter word to add to exclusions...",
        add: "Add",
        userWords: (count) => `User words (${count}):`,
        totalWords: "Total words:",
        totalWordsFiltered: "Total words (filtered):",
        uniqueWords: "Unique words:",
        uniqueWordsFiltered: "Unique words (filtered):",
        excludedInfo: (words, occurrences) => `Excluded ${words} words covering ${occurrences} occurrences`,
        longestWord: "Longest word:",
        lastUpdated: "Last updated:",
        word: "Word",
        count: "Count",
        noWords: "No words to display. Try reducing the \"Exclude top words\" setting.",
        processing: (current, total) => `Processing files: ${current} / ${total}`,
        clickToGenerate: "Click \"Refresh Statistics\" to generate word statistics",
        errorRefreshing: "Error refreshing statistics",
        errorProcessing: (file) => `Error processing file: ${file}`,
        showChart: "Show Chart",
        showTable: "Show Table",
        chartTitle: "Top Words Frequency",
        
        // Settings
        settings_title: "Word Statistics Settings",
        settings_language: "Language",
        settings_languageDesc: "Select language for word statistics",
        settings_minWordLength: "Minimum word length",
        settings_minWordLengthDesc: "Words shorter than this length will be ignored",
        settings_excludeTopWords: "Exclude top common words",
        settings_excludeTopWordsDesc: (lang) => `Exclude the top N most common ${lang} words from statistics (0-100)`,
        settings_additionalExcludedWords: "Additional excluded words",
        settings_additionalExcludedWordsDesc: "Comma-separated list of additional words to exclude",
        settings_enableCaching: "Enable caching",
        settings_enableCachingDesc: "Save statistics between sessions for faster loading",
        settings_contentFiltering: "Content Filtering",
        settings_ignoreMarkdownSyntax: "Ignore Markdown syntax",
        settings_ignoreMarkdownSyntaxDesc: "Exclude Markdown formatting characters",
        settings_ignoreUrls: "Ignore URLs and links",
        settings_ignoreUrlsDesc: "Exclude URLs and Markdown links from word count",
        settings_ignoreCodeBlocks: "Ignore code blocks",
        settings_ignoreCodeBlocksDesc: "Exclude code blocks and inline code from word count",
        settings_ignoreFrontmatter: "Ignore frontmatter",
        settings_ignoreFrontmatterDesc: "Exclude YAML frontmatter from word count",
        settings_ignoreMathBlocks: "Ignore math blocks",
        settings_ignoreMathBlocksDesc: "Exclude math formulas and equations from word count",
        settings_ignoreTags: "Ignore tags and mentions",
        settings_ignoreTagsDesc: "Exclude hashtags and mentions from word count",
        settings_languageMethods: "Lemmatization Methods",
        settings_languageStats: "Dictionary Statistics",
        settings_languageStatsDesc: "Show current dictionary loading status",
        settings_reloadDictionaries: "Reload Dictionaries",
        settings_reloadDictionariesDesc: "Reload dictionaries from GitHub",
        settings_createTestFile: "Create Test File",
        settings_createTestFileDesc: "Create a file to test lemmatization functionality",
        settings_expectedStats: "Expected Statistics",
        settings_expectedStatsDesc: "Show expected statistics for test poem",
        settings_runStrictTest: "Run Strict Test",
        settings_runStrictTestDesc: "Run comprehensive lemmatization test with strict validation",
        
        // Dictionary messages
        dict_loaded: "Dictionaries loaded successfully",
        dict_reloaded: "Dictionaries reloaded",
        test_created: "Test file created/updated",
        test_passed: "Test passed",
        test_failed: "Test failed"
    },
    chinese: {
        title: "ÂçïËØçÁªüËÆ°",
        refresh: "Âà∑Êñ∞ÁªüËÆ°",
        refreshing: "Âà∑Êñ∞‰∏≠...",
        language: "ËØ≠Ë®Ä:",
        excludeTopWords: (count, lang) => `ÊéíÈô§Ââç ${count} ‰∏™${lang}ÂçïËØç`,
        addUserWords: "Ê∑ªÂä†Ë¶ÅÊéíÈô§ÁöÑÁî®Êà∑ÂçïËØç:",
        placeholder: "ËæìÂÖ•Ë¶ÅÊ∑ªÂä†Âà∞ÊéíÈô§ÂàóË°®ÁöÑÂçïËØç...",
        add: "Ê∑ªÂä†",
        userWords: (count) => `Áî®Êà∑ÂçïËØç (${count}):`,
        totalWords: "ÊÄªÂçïËØçÊï∞:",
        totalWordsFiltered: "ÊÄªÂçïËØçÊï∞ÔºàËøáÊª§ÂêéÔºâ:",
        uniqueWords: "ÂîØ‰∏ÄÂçïËØç:",
        uniqueWordsFiltered: "ÂîØ‰∏ÄÂçïËØçÔºàËøáÊª§ÂêéÔºâ:",
        excludedInfo: (words, occurrences) => `Â∑≤ÊéíÈô§ ${words} ‰∏™ÂçïËØçÔºåË¶ÜÁõñ ${occurrences} ‰∏™Âá∫Áé∞`,
        longestWord: "ÊúÄÈïøÂçïËØç:",
        lastUpdated: "ÊúÄÂêéÊõ¥Êñ∞:",
        word: "ÂçïËØç",
        count: "ËÆ°Êï∞",
        noWords: "Ê≤°ÊúâÂèØÊòæÁ§∫ÁöÑÂçïËØç„ÄÇÂ∞ùËØïÂáèÂ∞ë\"ÊéíÈô§Â∏∏ËßÅÂçïËØç\"ËÆæÁΩÆ„ÄÇ",
        processing: (current, total) => `Â§ÑÁêÜÊñá‰ª∂‰∏≠: ${current} / ${total}`,
        clickToGenerate: "ÁÇπÂáª\"Âà∑Êñ∞ÁªüËÆ°\"ÁîüÊàêÂçïËØçÁªüËÆ°",
        errorRefreshing: "Âà∑Êñ∞ÁªüËÆ°Êó∂Âá∫Èîô",
        errorProcessing: (file) => `Â§ÑÁêÜÊñá‰ª∂Êó∂Âá∫Èîô: ${file}`,
        showChart: "ÊòæÁ§∫ÂõæË°®",
        showTable: "ÊòæÁ§∫Ë°®Ê†º",
        chartTitle: "È´òÈ¢ëÂçïËØçÁªüËÆ°",
        
        // Settings
        settings_title: "ÂçïËØçÁªüËÆ°ËÆæÁΩÆ",
        settings_language: "ËØ≠Ë®Ä",
        settings_languageDesc: "ÈÄâÊã©ÂçïËØçÁªüËÆ°ÁöÑËØ≠Ë®Ä",
        settings_minWordLength: "ÊúÄÂ∞èÂçïËØçÈïøÂ∫¶",
        settings_minWordLengthDesc: "Áü≠‰∫éÊ≠§ÈïøÂ∫¶ÁöÑÂçïËØçÂ∞ÜË¢´ÂøΩÁï•",
        settings_excludeTopWords: "ÊéíÈô§Â∏∏ËßÅÂçïËØç",
        settings_excludeTopWordsDesc: (lang) => `‰ªéÁªüËÆ°‰∏≠ÊéíÈô§Ââç N ‰∏™${lang}ÂçïËØç (0-100)`,
        settings_additionalExcludedWords: "È¢ùÂ§ñÊéíÈô§ÁöÑÂçïËØç",
        settings_additionalExcludedWordsDesc: "ÈÄóÂè∑ÂàÜÈöîÁöÑÈ¢ùÂ§ñÊéíÈô§ÂçïËØçÂàóË°®",
        settings_enableCaching: "ÂêØÁî®ÁºìÂ≠ò",
        settings_enableCachingDesc: "Âú®‰ºöËØù‰πãÈó¥‰øùÂ≠òÁªüËÆ°‰ø°ÊÅØ‰ª•‰æøÂø´ÈÄüÂä†ËΩΩ",
        settings_contentFiltering: "ÂÜÖÂÆπËøáÊª§",
        settings_ignoreMarkdownSyntax: "ÂøΩÁï• Markdown ËØ≠Ê≥ï",
        settings_ignoreMarkdownSyntaxDesc: "ÊéíÈô§ Markdown Ê†ºÂºèÂ≠óÁ¨¶",
        settings_ignoreUrls: "ÂøΩÁï• URL ÂíåÈìæÊé•",
        settings_ignoreUrlsDesc: "‰ªéÂçïËØçËÆ°Êï∞‰∏≠ÊéíÈô§ URL Âíå Markdown ÈìæÊé•",
        settings_ignoreCodeBlocks: "ÂøΩÁï•‰ª£Á†ÅÂùó",
        settings_ignoreCodeBlocksDesc: "‰ªéÂçïËØçËÆ°Êï∞‰∏≠ÊéíÈô§‰ª£Á†ÅÂùóÂíåÂÜÖËÅî‰ª£Á†Å",
        settings_ignoreFrontmatter: "ÂøΩÁï• Frontmatter",
        settings_ignoreFrontmatterDesc: "‰ªéÂçïËØçËÆ°Êï∞‰∏≠ÊéíÈô§ YAML frontmatter",
        settings_ignoreMathBlocks: "ÂøΩÁï•Êï∞Â≠¶Âùó",
        settings_ignoreMathBlocksDesc: "‰ªéÂçïËØçËÆ°Êï∞‰∏≠ÊéíÈô§Êï∞Â≠¶ÂÖ¨ÂºèÂíåÊñπÁ®ã",
        settings_ignoreTags: "ÂøΩÁï•Ê†áÁ≠æÂíåÊèêÂèä",
        settings_ignoreTagsDesc: "‰ªéÂçïËØçËÆ°Êï∞‰∏≠ÊéíÈô§Ê†áÁ≠æÂíåÊèêÂèä",
        settings_languageMethods: "ËØçÂΩ¢ËøòÂéüÊñπÊ≥ï",
        settings_languageStats: "Â≠óÂÖ∏ÁªüËÆ°",
        settings_languageStatsDesc: "ÊòæÁ§∫ÂΩìÂâçÂ≠óÂÖ∏Âä†ËΩΩÁä∂ÊÄÅ",
        settings_reloadDictionaries: "ÈáçÊñ∞Âä†ËΩΩÂ≠óÂÖ∏",
        settings_reloadDictionariesDesc: "‰ªé GitHub ÈáçÊñ∞Âä†ËΩΩÂ≠óÂÖ∏",
        settings_createTestFile: "ÂàõÂª∫ÊµãËØïÊñá‰ª∂",
        settings_createTestFileDesc: "ÂàõÂª∫Áî®‰∫éÊµãËØïËØçÂΩ¢ËøòÂéüÂäüËÉΩÁöÑÊñá‰ª∂",
        settings_expectedStats: "È¢ÑÊúüÁªüËÆ°",
        settings_expectedStatsDesc: "ÊòæÁ§∫ÊµãËØïËØóÁöÑÈ¢ÑÊúüÁªüËÆ°",
        settings_runStrictTest: "ËøêË°å‰∏•Ê†ºÊµãËØï",
        settings_runStrictTestDesc: "ËøêË°åÂÖ∑Êúâ‰∏•Ê†ºÈ™åËØÅÁöÑÁªºÂêàËØçÂΩ¢ËøòÂéüÊµãËØï",
        
        // Dictionary messages
        dict_loaded: "Â≠óÂÖ∏Âä†ËΩΩÊàêÂäü",
        dict_reloaded: "Â≠óÂÖ∏ÈáçÊñ∞Âä†ËΩΩ",
        test_created: "ÊµãËØïÊñá‰ª∂Â∑≤ÂàõÂª∫/Êõ¥Êñ∞",
        test_passed: "ÊµãËØïÈÄöËøá",
        test_failed: "ÊµãËØïÂ§±Ë¥•"
    }
};

// Word Statistics View with Linear Chart
var WordStatisticsView = class extends import_obsidian.ItemView {
    constructor(leaf, plugin) {
        super(leaf);
        this.eventListeners = new Map();
        this.infoEl = null;
        this.listContainer = null;
        this.displayMode = "table";
        this.plugin = plugin;
        this.chart = null;
        this.chartResizeObserver = null;
    }

    getViewType() {
        return "word-stats-view";
    }

    getDisplayText() {
        return this.t("title");
    }

    t(key, ...params) {
        const translation = TRANSLATIONS[this.plugin.settings.language][key];
        return typeof translation === "function" ? translation(...params) : translation;
    }

    async onOpen() {
        await this.drawStats();
    }

    clearEventListeners() {
        for (const [element, { event, callback }] of this.eventListeners) {
            element.removeEventListener(event, callback);
        }
        this.eventListeners.clear();
    }

    addEventListener(element, event, callback) {
        element.addEventListener(event, callback);
        this.eventListeners.set(element, { event, callback });
    }

    showProgress(current, total) {
        const container = this.containerEl.children[1];
        container.empty();
        const progressEl = container.createEl("div", { cls: "word-stats-progress" });
        progressEl.createEl("div", {
            text: this.t("processing", current, total)
        });
        const progressBar = progressEl.createEl("div", { cls: "word-stats-progress-bar" });
        progressBar.createEl("div", {
            cls: "word-stats-progress-fill",
            attr: { style: `width: ${(current / total) * 100}%` }
        });
    }

    updateProgress(current, total) {
        const progressEl = this.containerEl.querySelector(".word-stats-progress");
        if (progressEl) {
            const textEl = progressEl.querySelector("div");
            const fillEl = progressEl.querySelector(".word-stats-progress-fill");
            if (textEl)
                textEl.setText(this.t("processing", current, total));
            if (fillEl)
                fillEl.style.width = `${(current / total) * 100}%`;
        }
    }

    async drawStats() {
        this.clearEventListeners();
        if (this.chart) {
            this.chart.destroy();
            this.chart = null;
        }
        
        // Clean up existing ResizeObserver
        if (this.chartResizeObserver) {
            this.chartResizeObserver.disconnect();
            this.chartResizeObserver = null;
        }
        
        const container = this.containerEl.children[1];
        container.empty();

        const statsEl = container.createEl("div", { cls: "word-stats-container" });
        const headerEl = statsEl.createEl("div", { cls: "word-stats-header" });
        
        // Title with icon
        const titleEl = headerEl.createEl("div", { cls: "word-stats-title-container" });
        titleEl.createEl("span", { cls: "word-stats-icon" }).innerHTML = "üìä";
        titleEl.createEl("h3", { text: this.t("title"), cls: "word-stats-title" });

        const buttonsContainer = headerEl.createEl("div", { cls: "word-stats-buttons" });
        
        const refreshButton = buttonsContainer.createEl("button", {
            text: "üîÑ " + this.t("refresh"),
            cls: "word-stats-btn word-stats-btn-primary"
        });
        
        const viewToggleButton = buttonsContainer.createEl("button", {
            text: this.displayMode === "table" ? "üìà " + this.t("showChart") : "üìã " + this.t("showTable"),
            cls: "word-stats-btn word-stats-btn-secondary"
        });

        this.addEventListener(refreshButton, "click", async () => {
            refreshButton.setText("‚è≥ " + this.t("refreshing"));
            refreshButton.setAttribute("disabled", "true");
            viewToggleButton.setAttribute("disabled", "true");
            try {
                await this.plugin.collectAllStats();
                await this.drawStats();
                this.showStyledNotice("‚úÖ " + this.t("dict_loaded"), 'success');
            } catch (error) {
                this.showStyledNotice("‚ùå " + this.t("errorRefreshing"), 'error');
                console.error("Error refreshing statistics:", error);
            } finally {
                refreshButton.setText("üîÑ " + this.t("refresh"));
                refreshButton.removeAttribute("disabled");
                viewToggleButton.removeAttribute("disabled");
            }
        });

        this.addEventListener(viewToggleButton, "click", () => {
            this.displayMode = this.displayMode === "table" ? "chart" : "table";
            viewToggleButton.setText(this.displayMode === "table" ? "üìà " + this.t("showChart") : "üìã " + this.t("showTable"));
            this.updateStatsDisplay();
        });

        if (this.plugin.allStats.size === 0) {
            const loadingEl = statsEl.createEl("div", { cls: "word-stats-loading" });
            loadingEl.innerHTML = `
                <div class="word-stats-empty-state">
                    <div class="word-stats-empty-icon">üìä</div>
                    <h3>${this.t("title")}</h3>
                    <p>${this.t("clickToGenerate")}</p>
                    <button class="word-stats-btn word-stats-btn-primary" id="initial-refresh">
                        üöÄ ${this.t("refresh")}
                    </button>
                </div>
            `;
            
            const initialRefreshBtn = loadingEl.querySelector("#initial-refresh");
            this.addEventListener(initialRefreshBtn, "click", async () => {
                await this.plugin.collectAllStats();
                await this.drawStats();
            });
            
            return;
        }

        // Language selector with flag
        const languageContainer = statsEl.createEl("div", { cls: "word-stats-language-container" });
        languageContainer.createEl("label", {
            text: "üåç " + this.t("language"),
            cls: "word-stats-language-label"
        });
        const languageSelect = languageContainer.createEl("select", {
            cls: "word-stats-language-select"
        });

        const languages = [
            { value: "russian", name: "üá∑üá∫ –†—É—Å—Å–∫–∏–π", flag: "üá∑üá∫" },
            { value: "english", name: "üá∫üá∏ English", flag: "üá∫üá∏" },
            { value: "chinese", name: "üá®üá≥ ‰∏≠Êñá", flag: "üá®üá≥" }
        ];

        languages.forEach((lang) => {
            const option = languageSelect.createEl("option", {
                value: lang.value,
                text: lang.name
            });
            if (lang.value === this.plugin.settings.language) {
                option.setAttribute("selected", "true");
            }
        });

        this.addEventListener(languageSelect, "change", async (e) => {
            const value = e.target.value;
            this.plugin.settings.language = value;
            await this.plugin.saveSettings(true);
            this.drawStats();
        });

        // Controls section
        const controlsEl = statsEl.createEl("div", { cls: "word-stats-controls" });
        
        // Slider for top words exclusion
        const sliderContainer = controlsEl.createEl("div", { cls: "word-stats-slider-container" });
        const currentLanguageName = this.plugin.getCurrentLanguageDisplayName();
        const sliderLabel = sliderContainer.createEl("label", {
            text: `üîù ${this.t("excludeTopWords", this.plugin.settings.excludeTopWords, currentLanguageName)}`,
            cls: "word-stats-slider-label"
        });
        
        const sliderWrapper = sliderContainer.createEl("div", { cls: "word-stats-slider-wrapper" });
        const slider = sliderWrapper.createEl("input", {
            type: "range",
            cls: "word-stats-slider"
        });
        slider.setAttribute("min", "0");
        slider.setAttribute("max", "100");
        slider.setAttribute("value", this.plugin.settings.excludeTopWords.toString());
        slider.setAttribute("step", "1");

        const sliderValue = sliderWrapper.createEl("span", {
            text: this.plugin.settings.excludeTopWords + "%",
            cls: "word-stats-slider-value"
        });

        this.addEventListener(slider, "input", (e) => {
            const value = e.target.value;
            this.plugin.settings.excludeTopWords = parseInt(value);
            this.plugin.updateFilteredStats();
            sliderLabel.setText(`üîù ${this.t("excludeTopWords", parseInt(value), currentLanguageName)}`);
            sliderValue.setText(value + "%");
            this.plugin.saveSettings(false).catch(console.error);
            this.updateStatsDisplay();
        });

        // User words input
        const userWordsContainer = controlsEl.createEl("div", { cls: "word-stats-user-words" });
        userWordsContainer.createEl("label", {
            text: "‚úèÔ∏è " + this.t("addUserWords"),
            cls: "word-stats-user-words-label"
        });
        
        const userWordsInputContainer = userWordsContainer.createEl("div", {
            cls: "word-stats-user-words-input-container"
        });
        
        const userWordsInput = userWordsInputContainer.createEl("input", {
            type: "text",
            cls: "word-stats-user-words-input",
            attr: { placeholder: this.t("placeholder") }
        });
        
        const userWordsButton = userWordsInputContainer.createEl("button", {
            text: "‚ûï " + this.t("add"),
            cls: "word-stats-btn word-stats-user-words-button"
        });

        this.addEventListener(userWordsButton, "click", () => {
            const word = userWordsInput.value.trim();
            if (word) {
                this.plugin.addUserWord(word);
                userWordsInput.value = "";
                this.updateStatsDisplay();
                this.showStyledNotice(`‚úÖ "${word}" ${this.t("add")}`, 'success');
            }
        });

        this.addEventListener(userWordsInput, "keypress", (e) => {
            if (e.key === "Enter") {
                const word = userWordsInput.value.trim();
                if (word) {
                    this.plugin.addUserWord(word);
                    userWordsInput.value = "";
                    this.updateStatsDisplay();
                    this.showStyledNotice(`‚úÖ "${word}" ${this.t("add")}`, 'success');
                }
            }
        });

        if (this.plugin.userWords.size > 0) {
            const userWordsList = userWordsContainer.createEl("div", { cls: "word-stats-user-words-list" });
            userWordsList.createEl("div", {
                text: `üóëÔ∏è ${this.t("userWords", this.plugin.userWords.size)}`,
                cls: "word-stats-user-words-header"
            });
            
            const userWordsItems = userWordsList.createEl("div", { cls: "word-stats-user-words-items" });
            Array.from(this.plugin.userWords).forEach((word) => {
                const itemEl = userWordsItems.createEl("div", { cls: "word-stats-user-words-item" });
                itemEl.setText(word);
                const removeBtn = itemEl.createEl("button", {
                    text: "‚ùå",
                    cls: "word-stats-user-words-remove"
                });
                this.addEventListener(removeBtn, "click", () => {
                    this.plugin.removeUserWord(word);
                    this.updateStatsDisplay();
                    this.showStyledNotice(`‚úÖ "${word}" ${this.t("remove")}`, 'success');
                });
            });
        }

        // Info panel
        this.infoEl = statsEl.createEl("div", { cls: "word-stats-info" });
        
        // Stats display area
        this.listContainer = statsEl.createEl("div", { cls: "word-stats-list-container" });
        this.updateStatsDisplay();
    }

    updateStatsDisplay() {
        if (!this.infoEl || !this.listContainer) return;
        
        this.updateInfoPanel();
        if (this.displayMode === "table") {
            this.updateWordList();
        } else {
            this.drawBeautifulChart();
        }
    }

    updateInfoPanel() {
        if (!this.infoEl) return;
        this.infoEl.empty();
        
        const filteredStats = this.plugin.filteredStats;
        const excludedCount = this.plugin.getExcludedWordsCount();
        const totalWordsAll = Array.from(this.plugin.allStats.values()).reduce((sum, stat) => sum + stat.count, 0);
        const totalWordsFiltered = Array.from(filteredStats.values()).reduce((sum, stat) => sum + stat.count, 0);

        const infoGrid = this.infoEl.createEl("div", { cls: "word-stats-info-grid" });
        
        // Total words card
        const totalCard = infoGrid.createEl("div", { cls: "word-stats-info-card" });
        totalCard.createEl("div", { cls: "word-stats-info-icon" }).innerHTML = "üì¶";
        totalCard.createEl("div", { cls: "word-stats-info-value", text: totalWordsAll.toLocaleString() });
        totalCard.createEl("div", { cls: "word-stats-info-label", text: this.t("totalWords") });

        // Filtered words card
        const filteredCard = infoGrid.createEl("div", { cls: "word-stats-info-card" });
        filteredCard.createEl("div", { cls: "word-stats-info-icon" }).innerHTML = "üéØ";
        filteredCard.createEl("div", { cls: "word-stats-info-value", text: totalWordsFiltered.toLocaleString() });
        filteredCard.createEl("div", { cls: "word-stats-info-label", text: this.t("totalWordsFiltered") });

        // Unique words card
        const uniqueCard = infoGrid.createEl("div", { cls: "word-stats-info-card" });
        uniqueCard.createEl("div", { cls: "word-stats-info-icon" }).innerHTML = "‚ú®";
        uniqueCard.createEl("div", { cls: "word-stats-info-value", text: this.plugin.allStats.size.toLocaleString() });
        uniqueCard.createEl("div", { cls: "word-stats-info-label", text: this.t("uniqueWords") });

        // Filtered unique words card
        const uniqueFilteredCard = infoGrid.createEl("div", { cls: "word-stats-info-card" });
        uniqueFilteredCard.createEl("div", { cls: "word-stats-info-icon" }).innerHTML = "‚≠ê";
        uniqueFilteredCard.createEl("div", { cls: "word-stats-info-value", text: filteredStats.size.toLocaleString() });
        uniqueFilteredCard.createEl("div", { cls: "word-stats-info-label", text: this.t("uniqueWordsFiltered") });

        // Additional info
        const additionalInfo = this.infoEl.createEl("div", { cls: "word-stats-additional-info" });
        
        if (excludedCount > 0) {
            const excludedWordsCount = totalWordsAll - totalWordsFiltered;
            additionalInfo.createEl("div", {
                text: `üö´ ${this.t("excludedInfo", excludedCount, excludedWordsCount.toLocaleString())}`,
                cls: "word-stats-excluded-info"
            });
        }

        if (this.plugin.longestWord) {
            const lengthText = this.plugin.settings.language === "english" ? "letters" : 
                             this.plugin.settings.language === "russian" ? "–±—É–∫–≤" : "Â≠óÊØç";
            additionalInfo.createEl("div", { 
                text: `üìè ${this.t("longestWord")} "${this.plugin.longestWord.word}" (${this.plugin.longestWord.length} ${lengthText})`,
                cls: "word-stats-longest-word"
            });
        }

        if (this.plugin.lastUpdate) {
            additionalInfo.createEl("div", {
                text: `üïí ${this.t("lastUpdated")} ${new Date(this.plugin.lastUpdate).toLocaleString()}`,
                cls: "word-stats-last-updated"
            });
        }
    }

    updateWordList() {
        if (!this.listContainer) return;
        this.listContainer.empty();
        
        // –£–ë–ò–†–ê–ï–ú .slice(0, 100) —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –í–°–ï —Å–ª–æ–≤–∞
        const displayStats = Array.from(this.plugin.filteredStats.entries())
            .sort(([, a], [, b]) => b.count - a.count);
            // .slice(0, 100); // –£–î–ê–õ–ï–ù–û: —Ç–µ–ø–µ—Ä—å –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å–ª–æ–≤–∞

        const listHeader = this.listContainer.createEl("div", { cls: "word-stats-list-header" });
        listHeader.createEl("span", { text: "üìù " + this.t("word") });
        listHeader.createEl("span", { text: "üî¢ " + this.t("count") });
        
        const listEl = this.listContainer.createEl("div", { cls: "word-stats-list" });

        displayStats.forEach(([key, stat], index) => {
            const itemEl = listEl.createEl("div", { cls: "word-stat-item" });
            
            const rankEl = itemEl.createEl("span", {
                cls: "word-stat-rank",
                text: `#${index + 1}`
            });
            
            const wordEl = itemEl.createEl("span", {
                cls: stat.isUserWord ? "word-stat-word user-word" : "word-stat-word",
                text: stat.baseForm
            });
            
            const countEl = itemEl.createEl("span", {
                cls: "word-stat-count",
                text: stat.count.toLocaleString()
            });

            // Add percentage bar
            const maxCount = displayStats[0]?.[1]?.count || 1;
            const percentage = (stat.count / maxCount) * 100;
            const barEl = itemEl.createEl("div", { cls: "word-stat-bar" });
            barEl.createEl("div", {
                cls: "word-stat-bar-fill",
                attr: { style: `width: ${percentage}%` }
            });
        });

        if (displayStats.length === 0) {
            const emptyState = this.listContainer.createEl("div", { cls: "word-stats-empty-state" });
            emptyState.innerHTML = `
                <div class="word-stats-empty-icon">üìù</div>
                <h3>${this.t("noWords")}</h3>
                <p>${this.t("noWords")}</p>
            `;
        }
    }

    // NEW: Method for styled notices
    showStyledNotice(message, type = 'info') {
        const notice = new import_obsidian.Notice('', 4000);
        const noticeEl = notice.noticeEl;
        noticeEl.addClass('word-stats-notice');
        noticeEl.addClass(`word-stats-notice-${type}`);
        noticeEl.setText(message);
    }

    // UPDATED: Linear chart implementation with horizontal labels
    drawBeautifulChart() {
        if (!this.listContainer) return;
        this.listContainer.empty();
        
        // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–ø-100 —Å–ª–æ–≤ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
        const displayStats = Array.from(this.plugin.filteredStats.entries())
            .sort(([, a], [, b]) => b.count - a.count)
            .slice(0, 100);

        if (displayStats.length === 0) {
            const emptyState = this.listContainer.createEl("div", { cls: "word-stats-empty-state" });
            emptyState.innerHTML = `
                <div class="word-stats-empty-icon">üìä</div>
                <h3>${this.t("noWords")}</h3>
                <p>${this.t("noWords")}</p>
            `;
            return;
        }

        const chartContainer = this.listContainer.createEl("div", { 
            cls: "word-stats-chart-container" 
        });
        
        // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≥—Ä–∞—Ñ–∏–∫–µ
        const chartInfo = chartContainer.createEl("div", { cls: "word-stats-chart-info" });
        const chartStats = chartInfo.createEl("div", { cls: "word-stats-chart-stats" });
        
        chartStats.createEl("div", { 
            cls: "word-stats-chart-stat",
            text: `üìä –°–ª–æ–≤: ${displayStats.length}` 
        });
        
        const maxCount = Math.max(...displayStats.map(([, stat]) => stat.count));
        const minCount = Math.min(...displayStats.map(([, stat]) => stat.count));
        
        chartStats.createEl("div", { 
            cls: "word-stats-chart-stat",
            text: `üìà –ú–∞–∫—Å: ${maxCount}` 
        });
        
        chartStats.createEl("div", { 
            cls: "word-stats-chart-stat",
            text: `üìâ –ú–∏–Ω: ${minCount}` 
        });

        // –õ–µ–≥–µ–Ω–¥–∞
        const legend = chartInfo.createEl("div", { cls: "word-stats-chart-legend" });
        const legendItem = legend.createEl("div", { cls: "word-stats-legend-item" });
        legendItem.createEl("div", { 
            cls: "word-stats-legend-line",
            attr: { style: `background: var(--interactive-accent)` }
        });
        legendItem.createEl("span", { text: "–ß–∞—Å—Ç–æ—Ç–∞ —Å–ª–æ–≤" });

        // –û–±–µ—Ä—Ç–∫–∞ –¥–ª—è canvas —Å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º —Å–∫—Ä–æ–ª–ª–æ–º
        const chartWrapper = chartContainer.createEl("div", { 
            cls: "word-stats-chart-wrapper"
        });
        
        const canvasContainer = chartWrapper.createEl("div", {
            cls: "word-stats-canvas-container"
        });
        
        const canvas = canvasContainer.createEl("canvas", {
            cls: "word-stats-line-chart"
        });

        // –≠–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        const chartControls = chartContainer.createEl("div", { cls: "word-stats-chart-controls" });
        
        // –ü–æ–ª–∑—É–Ω–æ–∫ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        const sliderContainer = chartControls.createEl("div", { 
            cls: "word-stats-slider-container", 
            attr: { style: "flex: 1; display: flex; align-items: center; gap: 10px;" } 
        });
        
        sliderContainer.createEl("span", { 
            text: "‚Üê",
            attr: { style: "color: var(--text-muted); font-size: 14px;" }
        });
        
        const slider = sliderContainer.createEl("input", {
            type: "range",
            cls: "word-stats-chart-slider"
        });
        slider.setAttribute("min", "0");
        slider.setAttribute("max", "100");
        slider.setAttribute("value", "0");
        slider.setAttribute("step", "1");
        
        sliderContainer.createEl("span", { 
            text: "‚Üí",
            attr: { style: "color: var(--text-muted); font-size: 14px;" }
        });

        // –ö–Ω–æ–ø–∫–∏ –∑—É–º–∞
        const zoomContainer = chartControls.createEl("div", { cls: "word-stats-chart-zoom" });
        const zoomOut = zoomContainer.createEl("button", {
            text: "‚ûñ –£–º–µ–Ω—å—à–∏—Ç—å",
            cls: "word-stats-zoom-btn",
            attr: { title: "–£–º–µ–Ω—å—à–∏—Ç—å –º–∞—Å—à—Ç–∞–±" }
        });
        const zoomIn = zoomContainer.createEl("button", {
            text: "‚ûï –£–≤–µ–ª–∏—á–∏—Ç—å", 
            cls: "word-stats-zoom-btn",
            attr: { title: "–£–≤–µ–ª–∏—á–∏—Ç—å –º–∞—Å—à—Ç–∞–±" }
        });
        const resetZoom = zoomContainer.createEl("button", {
            text: "üîÑ –°–±—Ä–æ—Å–∏—Ç—å",
            cls: "word-stats-zoom-btn",
            attr: { title: "–°–±—Ä–æ—Å–∏—Ç—å –º–∞—Å—à—Ç–∞–±" }
        });

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ª–∏–Ω–µ–π–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞
        this.createLineChart(canvas, displayStats, slider, zoomOut, zoomIn, resetZoom, chartWrapper);
    }

    createLineChart(canvas, displayStats, slider, zoomOut, zoomIn, resetZoom, chartWrapper) {
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç canvas");
            return;
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞
        let zoomLevel = 1.0;
        let scrollPosition = 0;
        const minZoom = 0.5;
        const maxZoom = 3.0;
        const zoomStep = 0.2;

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∞–∑–æ–≤—ã–µ —Ä–∞–∑–º–µ—Ä—ã
        const calculateDimensions = () => {
            const baseWidth = Math.max(1200, displayStats.length * 50);
            const effectiveWidth = baseWidth * zoomLevel;
            const height = 500; // –£–≤–µ–ª–∏—á–∏–ª –≤—ã—Å–æ—Ç—É –¥–ª—è –ª—É—á—à–µ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–µ–π
            
            return { 
                width: effectiveWidth, 
                height, 
                baseWidth,
                effectiveWidth
            };
        };

        // –§—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞
        const drawChart = () => {
            const { width, height } = calculateDimensions();
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã canvas
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            // –û—á–∏—Å—Ç–∫–∞ canvas
            ctx.clearRect(0, 0, width, height);
            
            // –ï—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö, –≤—ã—Ö–æ–¥–∏–º
            if (displayStats.length === 0) return;
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
            const padding = { top: 50, right: 40, bottom: 120, left: 80 }; // –£–≤–µ–ª–∏—á–∏–ª bottom –¥–ª—è –ø–æ–¥–ø–∏—Å–µ–π
            const graphWidth = Math.max(0, width - padding.left - padding.right);
            const graphHeight = Math.max(0, height - padding.top - padding.bottom);
            
            if (graphWidth <= 0 || graphHeight <= 0) return;
            
            // –î–∞–Ω–Ω—ã–µ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
            const counts = displayStats.map(([, stat]) => stat.count);
            const maxValue = Math.max(...counts);
            const minValue = Math.min(...counts);
            const valueRange = maxValue - minValue;
            
            // –†–∏—Å—É–µ–º —Ñ–æ–Ω
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--background-primary') || '#ffffff';
            ctx.fillRect(0, 0, width, height);
            
            // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--background-modifier-border') || '#dddddd';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ —Å–µ—Ç–∫–∏ (–∑–Ω–∞—á–µ–Ω–∏—è Y)
            const horizontalLines = 5;
            for (let i = 0; i <= horizontalLines; i++) {
                const y = padding.top + (i * graphHeight / horizontalLines);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + graphWidth, y);
                ctx.stroke();
                
                // –ü–æ–¥–ø–∏—Å–∏ –∑–Ω–∞—á–µ–Ω–∏–π Y
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-muted') || '#666666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                const value = Math.round(maxValue - (i * valueRange / horizontalLines));
                ctx.fillText(value.toString(), padding.left - 10, y);
            }
            
            ctx.setLineDash([]);
            
            // –†–∏—Å—É–µ–º –æ—Å–∏
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text-muted') || '#666666';
            ctx.lineWidth = 2;
            
            // –û—Å—å Y
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + graphHeight);
            ctx.stroke();
            
            // –û—Å—å X
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + graphHeight);
            ctx.lineTo(padding.left + graphWidth, padding.top + graphHeight);
            ctx.stroke();
            
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–æ—á–∫–∏ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
            const points = [];
            for (let i = 0; i < displayStats.length; i++) {
                const x = padding.left + (i * graphWidth / (displayStats.length - 1));
                const y = valueRange === 0 ? 
                    padding.top + graphHeight / 2 : 
                    padding.top + graphHeight - ((displayStats[i][1].count - minValue) / valueRange) * graphHeight;
                
                points.push({
                    x,
                    y,
                    word: displayStats[i][0],
                    count: displayStats[i][1].count
                });
            }
            
            // –†–∏—Å—É–µ–º –æ–±–ª–∞—Å—Ç—å –ø–æ–¥ –ª–∏–Ω–∏–µ–π —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + graphHeight);
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.3)');
            gradient.addColorStop(1, 'rgba(102, 126, 234, 0.1)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(points[0].x, padding.top + graphHeight);
            for (const point of points) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineTo(points[points.length - 1].x, padding.top + graphHeight);
            ctx.closePath();
            ctx.fill();
            
            // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é –≥—Ä–∞—Ñ–∏–∫–∞
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--interactive-accent') || '#7e6df3';
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            
            // –†–∏—Å—É–µ–º —Ç–æ—á–∫–∏ –∏ –ø–æ–¥–ø–∏—Å–∏
            points.forEach((point, index) => {
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥–ø–∏—Å–∏ –¥–ª—è –ö–ê–ñ–î–û–ô —Ç–æ—á–∫–∏ (–∫–∞–∫ —Ç—Ä–µ–±–æ–≤–∞–ª–æ—Å—å)
                const showLabel = true;
                
                if (showLabel) {
                    // –ü–æ–¥–ø–∏—Å—å —Å–ª–æ–≤–∞ (–ø–æ–¥ –æ—Å—å—é X) - –ì–û–†–ò–ó–û–ù–¢–ê–õ–¨–ù–û (0 –≥—Ä–∞–¥—É—Å–æ–≤)
                    ctx.save();
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-muted') || '#666666';
                    ctx.font = '12px Arial'; // –£–≤–µ–ª–∏—á–∏–ª —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    
                    // –û–±—Ä–µ–∑–∞–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–ª–æ–≤–∞
                    let label = point.word;
                    if (label.length > 15) {
                        label = label.substring(0, 15) + '...';
                    }
                    
                    // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ (0 –≥—Ä–∞–¥—É—Å–æ–≤)
                    ctx.fillText(label, point.x, padding.top + graphHeight + 10);
                    ctx.restore();
                    
                    // –ü–æ–¥–ø–∏—Å—å –∑–Ω–∞—á–µ–Ω–∏—è (–Ω–∞–¥ —Ç–æ—á–∫–æ–π)
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-normal') || '#000000';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(point.count.toString(), point.x, point.y - 8);
                }
                
                // –†–∏—Å—É–µ–º —Ç–æ—á–∫—É —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
                const pointGradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, 6);
                pointGradient.addColorStop(0, getComputedStyle(document.body).getPropertyValue('--interactive-accent') || '#7e6df3');
                pointGradient.addColorStop(1, getComputedStyle(document.body).getPropertyValue('--interactive-accent-hover') || '#5a4fc9');
                
                ctx.fillStyle = pointGradient;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // –û–±–≤–æ–¥–∫–∞ —Ç–æ—á–∫–∏
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--background-primary') || '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –≥—Ä–∞—Ñ–∏–∫–∞
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-normal') || '#000000';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üìä ' + this.t("chartTitle"), width / 2, 20);
            
            // –ü–æ–¥–ø–∏—Å–∏ –æ—Å–µ–π
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-muted') || '#666666';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('–°–ª–æ–≤–∞', width / 2, height - 40);
            
            ctx.save();
            ctx.translate(30, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('–ß–∞—Å—Ç–æ—Ç–∞', 0, 0);
            ctx.restore();
        };

        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
        const updateScrollPosition = () => {
            const canvasWidth = canvas.width;
            const wrapperWidth = chartWrapper.clientWidth;
            const maxScroll = Math.max(0, canvasWidth - wrapperWidth);
            const newScroll = (scrollPosition / 100) * maxScroll;
            chartWrapper.scrollLeft = newScroll;
        };

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
        zoomIn.addEventListener('click', () => {
            if (zoomLevel < maxZoom) {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep);
                drawChart();
                updateScrollPosition();
            }
        });

        zoomOut.addEventListener('click', () => {
            if (zoomLevel > minZoom) {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomStep);
                drawChart();
                updateScrollPosition();
            }
        });

        resetZoom.addEventListener('click', () => {
            zoomLevel = 1.0;
            scrollPosition = 0;
            slider.value = "0";
            drawChart();
            updateScrollPosition();
            chartWrapper.scrollLeft = 0;
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª–∑—É–Ω–∫–∞
        slider.addEventListener('input', (e) => {
            scrollPosition = parseInt(e.target.value);
            updateScrollPosition();
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –∫–æ–ª–µ—Å–∏–∫–æ–º –º—ã—à–∏
        chartWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();
            chartWrapper.scrollLeft += e.deltaY;
        });

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–∑—É–Ω–∫–∞ –ø—Ä–∏ —Ä—É—á–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–µ
        chartWrapper.addEventListener('scroll', () => {
            const canvasWidth = canvas.width;
            const wrapperWidth = chartWrapper.clientWidth;
            const maxScroll = Math.max(1, canvasWidth - wrapperWidth);
            const currentScroll = chartWrapper.scrollLeft;
            scrollPosition = maxScroll === 0 ? 0 : (currentScroll / maxScroll) * 100;
            slider.value = scrollPosition.toString();
        });

        // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞
        drawChart();
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        let resizeTimeout;
        const handleResize = () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                drawChart();
                updateScrollPosition();
            }, 250);
        };

        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(chartWrapper);
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º observer –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
        this.chartResizeObserver = resizeObserver;
    }

    onClose() {
        this.clearEventListeners();
        
        // –û—á–∏—â–∞–µ–º ResizeObserver –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
        if (this.chartResizeObserver) {
            this.chartResizeObserver.disconnect();
            this.chartResizeObserver = null;
        }
        
        if (this.chart) {
            this.chart.destroy();
            this.chart = null;
        }
        this.infoEl = null;
        this.listContainer = null;
    }
};

// Main Plugin Class
var WordStatsPlugin = class extends import_obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.allStats = new Map();
        this.filteredStats = new Map();
        this.longestWord = null;
        this.lastUpdate = null;
        this.userWords = new Set();
        this.view = null;
        this.languageManager = new LanguageManager(this);
        
        this.topWords = {
            russian: [
                "–∏", "–≤", "–Ω–µ", "–Ω–∞", "—è", "–±—ã—Ç—å", "–æ–Ω", "—Å", "—á—Ç–æ", "–∞",
                "–ø–æ", "—ç—Ç–æ", "–æ–Ω–∞", "—ç—Ç–æ—Ç", "–∫", "–Ω–æ", "–æ–Ω–∏", "–º—ã", "–∫–∞–∫", "–∏–∑",
                "—É", "–∫–æ—Ç–æ—Ä—ã–π", "—Ç–æ", "–∑–∞", "—Å–≤–æ–π", "—á—Ç–æ", "–≤–µ—Å—å", "–≥–æ–¥", "–æ—Ç", "—Ç–∞–∫",
                "–æ", "–¥–ª—è", "—Ç—ã", "–∂–µ", "–≤—Å–µ", "—Ç–æ—Ç", "–º–æ—á—å", "–≤—ã", "—á–µ–ª–æ–≤–µ–∫", "—Ç–∞–∫–æ–π",
                "–µ–≥–æ", "—Å–∫–∞–∑–∞—Ç—å", "—Ç–æ–ª—å–∫–æ", "–∏–ª–∏", "–µ—â–µ", "–±—ã", "—Å–µ–±—è", "–æ–¥–∏–Ω", "–∫–∞–∫", "—É–∂–µ",
                "–¥–æ", "–≤—Ä–µ–º—è", "–µ—Å–ª–∏", "—Å–∞–º", "–¥—Ä—É–≥–æ–π", "–≤–æ—Ç", "–≥–æ–≤–æ—Ä–∏—Ç—å", "–Ω–∞—à", "–º–æ–π", "–∑–Ω–∞—Ç—å",
                "—Å—Ç–∞—Ç—å", "–ø—Ä–∏", "–¥–µ–ª–æ", "–∂–∏–∑–Ω—å", "–∫—Ç–æ", "–ø–µ—Ä–≤—ã–π", "–æ—á–µ–Ω—å", "–¥–≤–∞", "–¥–µ–Ω—å", "–µ—ë",
                "–Ω–æ–≤—ã–π", "—Ä—É–∫–∞", "–¥–∞–∂–µ", "–≤–æ", "—Å–æ", "—Ä–∞–∑", "–≥–¥–µ", "—Ç–∞–º", "–ø–æ–¥", "–º–æ–∂–Ω–æ",
                "–Ω—É", "–ª–∏", "–∫–æ–≥–¥–∞", "–¥–∞", "–∫–∞–∫–æ–π", "–Ω–∏—Ö", "—á–µ—Ä–µ–∑", "—Ç–µ–º", "–¥–ª—è", "–º—ã",
                "–ø–µ—Ä–µ–¥", "–±–µ–∑", "–ø–æ—Å–ª–µ", "–≤—ã", "–∫–∞–∫", "—Ç–æ–ª—å–∫–æ", "–ø–æ—á—Ç–∏", "–µ–π", "–∏–º", "–∏–Ω–æ–≥–¥–∞"
            ],
            english: [
                "the", "be", "to", "of", "and", "a", "in", "that", "have", "i",
                "it", "for", "not", "on", "with", "he", "as", "you", "do", "at",
                "this", "but", "his", "by", "from", "they", "we", "say", "her", "she",
                "or", "an", "will", "my", "one", "all", "would", "there", "their", "what",
                "so", "up", "out", "if", "about", "who", "get", "which", "go", "me",
                "when", "make", "can", "like", "time", "no", "just", "him", "know", "take",
                "people", "into", "year", "your", "good", "some", "could", "them", "see", "other",
                "than", "then", "now", "look", "only", "come", "its", "over", "think", "also",
                "back", "after", "use", "two", "how", "our", "work", "first", "well", "way",
                "even", "new", "want", "because", "any", "these", "give", "day", "most", "us"
            ],
            chinese: [
                "ÁöÑ", "ÊòØ", "Âú®", "Êúâ", "Âíå", "‰∫Ü", "‰∏ç", "Êàë", "‰ªñ", "Â•π",
                "ÂÆÉ", "Ëøô", "ÈÇ£", "‰Ω†", "‰ª¨", "‰∏™", "‰∫∫", "‰∏≠", "ÂõΩ", "‰∏ä",
                "‰∏ã", "Â§ß", "Â∞è", "Â§ö", "Â∞ë", "Â•Ω", "Âùè", "ÂØπ", "Èîô", "Êù•",
                "Âéª", "Áúã", "Âê¨", "ËØ¥", "ËØª", "ÂÜô", "Â≠¶", "‰π†", "Â∑•", "‰Ωú",
                "Áîü", "Ê¥ª", "ÂêÉ", "Âñù", "Áé©", "‰πê", "Â§©", "Âú∞", "Êó•", "Êúà"
            ]
        };
    }

    async onload() {
        console.log("üî§ Loading Language Statistics plugin...");
        await this.loadSettings();
        
        // Initialize language manager with dictionaries
        await this.languageManager.initialize();

        if (this.settings.enableCaching) {
            await this.loadCachedStats();
        }

        this.registerView("word-stats-view", (leaf) => {
            this.view = new WordStatisticsView(leaf, this);
            return this.view;
        });

        this.addRibbonIcon("bar-chart", "Language Statistics", () => {
            this.activateView();
        });

        this.addSettingTab(new WordStatsSettingTab(this.app, this));

        this.addCommand({
            id: "refresh-word-stats",
            name: "Refresh word statistics",
            callback: () => {
                this.collectAllStats();
            }
        });

        // Add strict test command
        this.addCommand({
            id: "run-strict-test",
            name: "Run strict lemmatization test",
            callback: async () => {
                try {
                    const results = await this.runStrictTest();
                    new import_obsidian.Notice(`‚úÖ ${TRANSLATIONS[this.settings.language].test_passed}: ${results.successRate.toFixed(1)}%`);
                } catch (error) {
                    new import_obsidian.Notice(`‚ùå ${TRANSLATIONS[this.settings.language].test_failed}: ${error.message}`);
                }
            }
        });

        console.log("‚úÖ Language Statistics plugin loaded successfully");
    }

    getCurrentLanguageName() {
        const names = {
            russian: "russian",
            english: "english",
            chinese: "chinese"
        };
        return names[this.settings.language];
    }

    getCurrentLanguageDisplayName() {
        const names = {
            russian: "—Ä—É—Å—Å–∫–∏—Ö",
            english: "English",
            chinese: "‰∏≠Êñá"
        };
        return names[this.settings.language];
    }

    lemmatizeWord(word) {
        return this.languageManager.lemmatizeWord(word, this.settings.language);
    }

    extractWords(text, filePath = "") {
        return this.languageManager.extractWords(text, this.settings.language, filePath);
    }

    async collectAllStats() {
        console.log("üîÑ Starting statistics collection...");
        this.allStats.clear();
        this.filteredStats.clear();
        this.longestWord = null;
        const files = this.app.vault.getMarkdownFiles();
        const totalFiles = files.length;
        let processedFiles = 0;

        if (this.view) {
            this.view.showProgress(0, totalFiles);
        }

        for (const file of files) {
            try {
                await this.processFile(file);
                processedFiles++;
                if (processedFiles % 10 === 0 || processedFiles === totalFiles) {
                    if (this.view) {
                        this.view.updateProgress(processedFiles, totalFiles);
                    }
                }
            } catch (error) {
                console.error(`Error processing file ${file.path}:`, error);
                const t = TRANSLATIONS[this.settings.language];
                new import_obsidian.Notice(t.errorProcessing(file.name));
            }
        }

        this.lastUpdate = Date.now();
        this.updateFilteredStats();

        if (this.settings.enableCaching) {
            await this.saveCachedStats();
        }

        if (this.view) {
            this.view.drawStats();
        }

        console.log(`‚úÖ Statistics collection completed: ${this.allStats.size} unique words found`);
        new import_obsidian.Notice(`‚úÖ ${TRANSLATIONS[this.settings.language].dict_loaded}: ${this.allStats.size} unique words`);
    }

    getExcludedWordsCount() {
        const topWords = this.topWords[this.settings.language];
        return Math.min(this.settings.excludeTopWords, topWords.length) + this.userWords.size;
    }

    updateFilteredStats() {
        this.filteredStats.clear();
        const topWords = this.topWords[this.settings.language];
        const excludedTopWords = topWords.slice(0, this.settings.excludeTopWords).map((word) => this.lemmatizeWord(word));
        const additionalExcluded = this.getAdditionalExcludedWords();
        const allExcludedWords = new Set([...excludedTopWords, ...this.userWords, ...additionalExcluded]);

        for (const [word, stats] of this.allStats.entries()) {
            if (!allExcludedWords.has(word)) {
                this.filteredStats.set(word, stats);
            }
        }
    }

    getAdditionalExcludedWords() {
        if (!this.settings.excludedWords.trim())
            return new Set();
        return new Set(this.settings.excludedWords.split(",").map((word) => this.lemmatizeWord(word.trim())).filter((word) => word.length > 0));
    }

    addUserWord(word) {
        const lemmatizedWord = this.lemmatizeWord(word);
        this.userWords.add(lemmatizedWord);
        this.updateFilteredStats();
        this.saveUserWords().catch(console.error);
        if (this.allStats.has(lemmatizedWord)) {
            const stats = this.allStats.get(lemmatizedWord);
            if (stats) {
                stats.isUserWord = true;
            }
        }
    }

    removeUserWord(word) {
        const lemmatizedWord = this.lemmatizeWord(word);
        this.userWords.delete(lemmatizedWord);
        this.updateFilteredStats();
        this.saveUserWords().catch(console.error);
        if (this.allStats.has(lemmatizedWord)) {
            const stats = this.allStats.get(lemmatizedWord);
            if (stats) {
                delete stats.isUserWord;
            }
        }
    }

    async saveUserWords() {
        const data = await this.loadData() || {};
        data.userWords = Array.from(this.userWords);
        await this.saveData(data);
    }

    async processFile(file) {
        try {
            const content = await this.app.vault.read(file);
            this.processContent(content, file.path);
        } catch (error) {
            console.error(`Error reading file ${file.path}:`, error);
            throw error;
        }
    }

    cleanMarkdownContent(text, filePath = "", language = "russian") {
        // Special handling for test files - extract only the poem
        if (filePath.includes("Lemmatization Test") || filePath.includes("Lemmatization_Test")) {
            return this.extractPoemContent(text, language);
        }

        let cleanedText = text;
        const processors = [
            [this.settings.ignoreFrontmatter, /^---\s*\n[\s\S]*?\n---\s*\n?/m, ""],
            [this.settings.ignoreCodeBlocks, /```[\s\S]*?```/g, ""],
            [this.settings.ignoreCodeBlocks, /`[^`\n]+`/g, ""],
            [this.settings.ignoreMathBlocks, /\$\$[\s\S]*?\$\$/g, ""],
            [this.settings.ignoreMathBlocks, /\$[^$\n]+\$/g, ""],
            [this.settings.ignoreUrls, /https?:\/\/[^\s\)]+/g, ""],
            [this.settings.ignoreUrls, /\[([^\]]+)\]\([^)]+\)/g, "$1"],
            [
                this.settings.ignoreUrls,
                /\[\[([^|\]]+)(?:\|([^\]]+))?\]\]/g,
                (match, link, text2) => text2 || link
            ],
            [this.settings.ignoreTags, /#[\w\u0400-\u04FF/-]+/g, ""],
            [this.settings.ignoreTags, /@[\w\u0400-\u04FF/-]+/g, ""],
            [this.settings.ignoreMarkdownSyntax, /^#{1,6}\s+/gm, ""],
            [this.settings.ignoreMarkdownSyntax, /^[\s]*([-*+]|\d+\.)\s+/gm, ""],
            [this.settings.ignoreMarkdownSyntax, /(\*\*|__)(.*?)\1/g, "$2"],
            [this.settings.ignoreMarkdownSyntax, /(\*|_)(.*?)\1/g, "$2"],
            [this.settings.ignoreMarkdownSyntax, /~~(.*?)~~/g, "$1"],
            [this.settings.ignoreMarkdownSyntax, /^>\s+/gm, ""],
            [this.settings.ignoreMarkdownSyntax, /^[\s]*[-*_]{3,}[\s]*$/gm, ""],
            [this.settings.ignoreMarkdownSyntax, /^\|.*\|$/gm, ""],
            [this.settings.ignoreMarkdownSyntax, /^\|[-:\s|]+\|$/gm, ""],
            [this.settings.ignoreMarkdownSyntax, /<[^>]+>/g, ""],
            [this.settings.ignoreMarkdownSyntax, /<!--[\s\S]*?-->/g, ""]
        ];

        processors.forEach(([shouldProcess, regex, replacement]) => {
            if (shouldProcess) {
                if (typeof replacement === "function") {
                    cleanedText = cleanedText.replace(regex, replacement);
                } else {
                    cleanedText = cleanedText.replace(regex, replacement);
                }
            }
        });
        return cleanedText;
    }

    // New function to extract only the poem from test files
    extractPoemContent(text, language) {
        // Return the full poem for the selected language
        return POEM_CONTENT[language] || "";
    }

    processContent(content, filePath) {
        const words = this.extractWords(content, filePath);
        
        words.forEach((word) => {
            if (!this.longestWord || word.length > this.longestWord.length) {
                this.longestWord = {
                    word,
                    length: word.length,
                    file: filePath
                };
            }

            const baseForm = word;
            const isUserWord = this.userWords.has(baseForm);
            const existing = this.allStats.get(baseForm);
            
            if (existing) {
                existing.count++;
                if (isUserWord) {
                    existing.isUserWord = true;
                }
            } else {
                this.allStats.set(baseForm, {
                    baseForm,
                    count: 1,
                    isUserWord
                });
            }
        });
    }

    getCacheData() {
        return {
            stats: Array.from(this.allStats.entries()),
            longestWord: this.longestWord,
            timestamp: this.lastUpdate || Date.now(),
            totalWords: Array.from(this.allStats.values()).reduce((sum, stat) => sum + stat.count, 0),
            uniqueWords: this.allStats.size
        };
    }

    async saveCachedStats() {
        const data = await this.loadData() || {};
        data.cache = this.getCacheData();
        data.language = this.settings.language;
        await this.saveData(data);
    }

    async loadCachedStats() {
        const data = await this.loadData();
        if (data?.cache && data.language === this.settings.language) {
            const cache = data.cache;
            this.allStats = new Map(cache.stats);
            this.longestWord = cache.longestWord;
            this.lastUpdate = cache.timestamp;
        } else {
            this.allStats.clear();
        }
        if (data?.userWords) {
            this.userWords = new Set(data.userWords);
        }
    }

    async activateView() {
        let leaf = this.app.workspace.getLeavesOfType("word-stats-view")[0];
        if (!leaf) {
            leaf = this.app.workspace.getRightLeaf(false);
            await leaf.setViewState({ type: "word-stats-view" });
        }
        this.app.workspace.revealLeaf(leaf);
    }

    async loadSettings() {
        const defaultSettings = {
            minWordLength: 1, // CHANGED FROM 2 TO 1
            excludedWords: "",
            ignoreMarkdownSyntax: true,
            ignoreUrls: true,
            ignoreCodeBlocks: true,
            ignoreFrontmatter: true,
            ignoreMathBlocks: true,
            ignoreTags: true,
            enableCaching: true,
            excludeTopWords: 0,
            language: "russian"
        };

        const data = await this.loadData();
        if (data?.settings) {
            this.settings = Object.assign(defaultSettings, data.settings);
        } else {
            this.settings = Object.assign(defaultSettings, data);
        }
        this.settings.minWordLength = Math.max(1, this.settings.minWordLength);
        this.settings.excludeTopWords = Math.max(0, Math.min(100, this.settings.excludeTopWords));
    }

    async saveSettings(shouldRecalcStats = false) {
        const data = await this.loadData() || {};
        data.settings = this.settings;
        await this.saveData(data);
        if (shouldRecalcStats) {
            await this.collectAllStats();
        } else {
            this.updateFilteredStats();
            if (this.view) {
                this.view.updateStatsDisplay();
            }
        }
    }

    // Add the strict test method to the plugin
    async runStrictTest() {
        const testSystem = new EnhancedTestSystem(this);
        return await testSystem.runStrictTest();
    }

    onunload() {
        if (this.settings.enableCaching) {
            this.saveCachedStats().catch(console.error);
        }
        console.log("üî§ Language Statistics plugin unloaded");
    }
};

// Settings Tab
var WordStatsSettingTab = class extends import_obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    t(key, ...params) {
        const translation = TRANSLATIONS[this.plugin.settings.language][key];
        return typeof translation === "function" ? translation(...params) : translation;
    }

    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", { text: this.t("settings_title") });

        // Language setting
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_language"))
            .setDesc(this.t("settings_languageDesc"))
            .addDropdown((dropdown) => dropdown
                .addOption("russian", "üá∑üá∫ –†—É—Å—Å–∫–∏–π")
                .addOption("english", "üá∫üá∏ English")
                .addOption("chinese", "üá®üá≥ ‰∏≠Êñá")
                .setValue(this.plugin.settings.language)
                .onChange(async (value) => {
                    this.plugin.settings.language = value;
                    await this.plugin.saveSettings(true);
                }));

        // Minimum word length
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_minWordLength"))
            .setDesc(this.t("settings_minWordLengthDesc"))
            .addText((text) => text
                .setPlaceholder("1")
                .setValue(String(this.plugin.settings.minWordLength))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue >= 1) {
                        this.plugin.settings.minWordLength = numValue;
                        await this.plugin.saveSettings(true);
                    }
                }));

        // Exclude top words
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_excludeTopWords"))
            .setDesc(this.t("settings_excludeTopWordsDesc", this.plugin.getCurrentLanguageName()))
            .addSlider((slider) => slider
                .setLimits(0, 100, 1)
                .setValue(this.plugin.settings.excludeTopWords)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.excludeTopWords = value;
                    await this.plugin.saveSettings(false);
                }));

        // Additional excluded words
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_additionalExcludedWords"))
            .setDesc(this.t("settings_additionalExcludedWordsDesc"))
            .addTextArea((text) => text
                .setPlaceholder("word1,word2,word3...")
                .setValue(this.plugin.settings.excludedWords)
                .onChange(async (value) => {
                    this.plugin.settings.excludedWords = value;
                    await this.plugin.saveSettings(false);
                }));

        // Enable caching
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_enableCaching"))
            .setDesc(this.t("settings_enableCachingDesc"))
            .addToggle((toggle) => toggle
                .setValue(this.plugin.settings.enableCaching)
                .onChange(async (value) => {
                    this.plugin.settings.enableCaching = value;
                    await this.plugin.saveSettings(false);
                }));

        // Language Methods
        containerEl.createEl("h3", { text: this.t("settings_languageMethods") });

        // Language statistics
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_languageStats"))
            .setDesc(this.t("settings_languageStatsDesc"))
            .addButton(button => button
                .setButtonText("üìä " + this.t("settings_languageStats"))
                .onClick(() => this.showLanguageStats()));

        // Expected statistics
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_expectedStats"))
            .setDesc(this.t("settings_expectedStatsDesc"))
            .addButton(button => button
                .setButtonText("üìà " + this.t("settings_expectedStats"))
                .onClick(() => this.showExpectedStats()));

        // Strict test button
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_runStrictTest"))
            .setDesc(this.t("settings_runStrictTestDesc"))
            .addButton(button => button
                .setButtonText("üß™ " + this.t("settings_runStrictTest"))
                .onClick(async () => {
                    button.setButtonText("‚è≥ " + this.t("refreshing"));
                    button.setDisabled(true);
                    try {
                        const results = await this.plugin.runStrictTest();
                        this.showTestResults(results);
                        if (results.successRate >= 80) {
                            new import_obsidian.Notice(`‚úÖ ${this.t("test_passed")}: ${results.successRate.toFixed(1)}%`);
                        } else {
                            new import_obsidian.Notice(`‚ùå ${this.t("test_failed")}: ${results.successRate.toFixed(1)}%`);
                        }
                    } catch (error) {
                        new import_obsidian.Notice(`üí• ${error.message}`);
                        console.error("Test failed:", error);
                    } finally {
                        button.setButtonText("üß™ " + this.t("settings_runStrictTest"));
                        button.setDisabled(false);
                    }
                }));

        // Reload dictionaries
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_reloadDictionaries"))
            .setDesc(this.t("settings_reloadDictionariesDesc"))
            .addButton(button => button
                .setButtonText("üîÑ " + this.t("settings_reloadDictionaries"))
                .onClick(async () => {
                    button.setButtonText("‚è≥ " + this.t("refreshing"));
                    button.setDisabled(true);
                    try {
                        await this.plugin.languageManager.reloadDictionaries();
                        new import_obsidian.Notice("‚úÖ " + this.t("dict_reloaded"));
                    } catch (error) {
                        new import_obsidian.Notice("‚ùå " + this.t("errorRefreshing"));
                        console.error("Error reloading dictionaries:", error);
                    } finally {
                        button.setButtonText("üîÑ " + this.t("settings_reloadDictionaries"));
                        button.setDisabled(false);
                    }
                }));

        // Create test file
        new import_obsidian.Setting(containerEl)
            .setName(this.t("settings_createTestFile"))
            .setDesc(this.t("settings_createTestFileDesc"))
            .addButton(button => button
                .setButtonText("üìù " + this.t("settings_createTestFile"))
                .onClick(() => this.createLemmatizationTestFile()));

        // Content Filtering
        containerEl.createEl("h3", { text: this.t("settings_contentFiltering") });

        const contentSettings = [
            { key: "ignoreMarkdownSyntax", name: this.t("settings_ignoreMarkdownSyntax"), desc: this.t("settings_ignoreMarkdownSyntaxDesc") },
            { key: "ignoreUrls", name: this.t("settings_ignoreUrls"), desc: this.t("settings_ignoreUrlsDesc") },
            { key: "ignoreCodeBlocks", name: this.t("settings_ignoreCodeBlocks"), desc: this.t("settings_ignoreCodeBlocksDesc") },
            { key: "ignoreFrontmatter", name: this.t("settings_ignoreFrontmatter"), desc: this.t("settings_ignoreFrontmatterDesc") },
            { key: "ignoreMathBlocks", name: this.t("settings_ignoreMathBlocks"), desc: this.t("settings_ignoreMathBlocksDesc") },
            { key: "ignoreTags", name: this.t("settings_ignoreTags"), desc: this.t("settings_ignoreTagsDesc") }
        ];

        contentSettings.forEach((setting) => {
            new import_obsidian.Setting(containerEl)
                .setName(setting.name)
                .setDesc(setting.desc)
                .addToggle((toggle) => toggle
                    .setValue(this.plugin.settings[setting.key])
                    .onChange(async (value) => {
                        this.plugin.settings[setting.key] = value;
                        await this.plugin.saveSettings(true);
                    }));
        });
    }

    async createLemmatizationTestFile() {
        const vault = this.plugin.app.vault;
        const fileName = "Lemmatization Test.md";
        
        const testContent = `# ${this.t("settings_createTestFile")}

${this.t("settings_createTestFileDesc")}

## –†—É—Å—Å–∫–æ–µ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ:

${POEM_CONTENT.russian}

## English poem:

${POEM_CONTENT.english}

## ‰∏≠ÊñáËØóÊ≠å:

${POEM_CONTENT.chinese}

## –û–∂–∏–¥–∞–µ–º–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ Expected statistics È¢ÑÊúüÁªüËÆ°Êï∞ÊçÆ:

### –†—É—Å—Å–∫–∏–π:
- –í—Å–µ–≥–æ —Å–ª–æ–≤: ${EXPECTED_STATS.russian.totalWords}
- –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–ª–æ–≤: ${EXPECTED_STATS.russian.uniqueWords}
- –¢–æ–ø —Å–ª–æ–≤–∞: ${EXPECTED_STATS.russian.topWords.map(w => `${w.word} (${w.count})`).join(', ')}

### English:
- Total words: ${EXPECTED_STATS.english.totalWords}
- Unique words: ${EXPECTED_STATS.english.uniqueWords}
- Top words: ${EXPECTED_STATS.english.topWords.map(w => `${w.word} (${w.count})`).join(', ')}

### ‰∏≠Êñá:
- ÊÄªÂçïËØçÊï∞: ${EXPECTED_STATS.chinese.totalWords}
- ÂîØ‰∏ÄÂçïËØç: ${EXPECTED_STATS.chinese.uniqueWords}
- È´òÈ¢ëÂçïËØç: ${EXPECTED_STATS.chinese.topWords.map(w => `${w.word} (${w.count})`).join(', ')}

## –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é:
1. –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–Ω—ã–µ —è–∑—ã–∫–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞
2. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–ª–æ–≤
3. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å—á–∏—Ç–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —è–∑—ã–∫–µ
4. –°—Ä–∞–≤–Ω–∏—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å –æ–∂–∏–¥–∞–µ–º–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –≤—ã—à–µ
5. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ü–ª–∞–≥–∏–Ω –±—É–¥–µ—Ç —Å—á–∏—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ –ø–æ–ª–Ω–æ–µ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —è–∑—ã–∫–µ, –∏–≥–Ω–æ—Ä–∏—Ä—É—è –≤–µ—Å—å –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç.

## Testing instructions:
1. Select different languages ‚Äã‚Äãin the plugin settings
2. Update the word statistics
3. Ensure that only the poem in the selected language is counted
4. Compare the results with the expected statistics above
5. Verify that lemmatization is working correctly

Note: The plugin will only count the full poem in the selected language, ignoring all other content.

## ÊµãËØïËØ¥ÊòéÔºö

1. Âú®Êèí‰ª∂ËÆæÁΩÆ‰∏≠ÈÄâÊã©‰∏çÂêåÁöÑËØ≠Ë®Ä

2. Êõ¥Êñ∞ËØçÈ¢ëÁªüËÆ°

3. Á°Æ‰øù‰ªÖÁªüËÆ°ÊâÄ‚Äã‚ÄãÈÄâËØ≠Ë®ÄÁöÑËØóÊ≠å

4. Â∞ÜÁªìÊûú‰∏é‰∏äËø∞È¢ÑÊúüÁªüËÆ°Êï∞ÊçÆËøõË°åÊØîËæÉ

5. È™åËØÅËØçÂΩ¢ËøòÂéüÂäüËÉΩÊòØÂê¶Ê≠£Â∏∏Â∑•‰Ωú

Ê≥®ÊÑèÔºöÊèí‰ª∂Âè™‰ºöÁªüËÆ°ÊâÄÈÄâËØ≠Ë®ÄÁöÑÂÆåÊï¥ËØóÊ≠åÔºåÂøΩÁï•ÊâÄÊúâÂÖ∂‰ªñÂÜÖÂÆπ„ÄÇ
`;

        try {
            let file = vault.getAbstractFileByPath(fileName);
            if (file) {
                await vault.modify(file, testContent);
            } else {
                file = await vault.create(fileName, testContent);
            }
            
            new import_obsidian.Notice("‚úÖ " + this.t("test_created"));
            
            // Open the test file
            const leaf = this.plugin.app.workspace.getLeaf(true);
            await leaf.openFile(file);
            
        } catch (error) {
            console.error("Error creating test file:", error);
            new import_obsidian.Notice("‚ùå " + this.t("errorProcessing", fileName));
        }
    }

    showLanguageStats() {
        const stats = this.plugin.languageManager.getLanguageStats();
        
        let message = this.t("settings_languageStats") + ":\n\n";
        for (const [lang, stat] of Object.entries(stats)) {
            const langName = {
                russian: "–†—É—Å—Å–∫–∏–π",
                english: "English", 
                chinese: "‰∏≠Êñá"
            }[lang];
            
            message += `${langName}:\n`;
            message += `  ${this.t("settings_languageStats")}: ${stat.method}\n`;
            message += `  ${this.t("status")}: ${stat.status}\n`;
            message += `  ${this.t("entries")}: ${stat.entries}\n`;
            message += `  ${this.t("description")}: ${stat.description}\n\n`;
        }
        
        const modal = new import_obsidian.Modal(this.plugin.app);
        modal.titleEl.setText(this.t("settings_languageStats"));
        
        const content = modal.contentEl;
        content.createEl("pre", { 
            text: message,
            cls: "language-stats-pre" 
        });
        
        const buttonContainer = content.createEl("div", { 
            cls: "modal-button-container" 
        });
        
        buttonContainer.createEl("button", {
            text: this.t("close"),
            cls: "mod-cta"
        }).addEventListener("click", () => modal.close());
        
        modal.open();
    }

    showExpectedStats() {
        const currentLang = this.plugin.settings.language;
        const expected = EXPECTED_STATS[currentLang];
        
        const langName = {
            russian: "–†—É—Å—Å–∫–∏–π",
            english: "English",
            chinese: "‰∏≠Êñá"
        }[currentLang];
        
        let message = `${this.t("settings_expectedStats")} –¥–ª—è ${langName}:\n\n`;
        message += `${this.t("totalWords")} ${expected.totalWords}\n`;
        message += `${this.t("uniqueWords")} ${expected.uniqueWords}\n\n`;
        message += `–¢–æ–ø ${Math.min(10, expected.topWords.length)} ${this.t("word")}:\n`;
        
        expected.topWords.slice(0, 10).forEach((word, index) => {
            message += `${index + 1}. ${word.word}: ${word.count} ${this.t("count")}\n`;
        });
        
        const modal = new import_obsidian.Modal(this.plugin.app);
        modal.titleEl.setText(this.t("settings_expectedStats"));
        
        const content = modal.contentEl;
        content.createEl("pre", { 
            text: message,
            cls: "expected-stats-pre" 
        });
        
        const buttonContainer = content.createEl("div", { 
            cls: "modal-button-container" 
        });
        
        buttonContainer.createEl("button", {
            text: this.t("close"),
            cls: "mod-cta"
        }).addEventListener("click", () => modal.close());
        
        modal.open();
    }

    showTestResults(results) {
        const modal = new import_obsidian.Modal(this.plugin.app);
        modal.titleEl.setText("üß™ " + this.t("settings_runStrictTest"));
        
        const content = modal.contentEl;
        
        // Overall result
        const overallResult = content.createEl("div", {
            cls: `test-overall-result ${results.successRate >= 80 ? "test-passed" : "test-failed"}`
        });
        overallResult.setText(`${this.t("overall")}: ${results.successRate.toFixed(1)}% (${results.passedTests}/${results.totalTests} ${this.t("passed")})`);

        // Individual test results
        results.results.forEach(result => {
            const resultEl = content.createEl("div", { 
                cls: `test-result ${result.passed ? "test-passed" : "test-failed"}`
            });
            resultEl.setText(`${result.passed ? "‚úÖ" : "‚ùå"} ${result.name}`);
            
            if (!result.passed && result.details) {
                const details = resultEl.createEl("div", { cls: "test-details" });
                details.createEl("div", { 
                    text: `${this.t("totalWords")}: ${this.t("expected")} ${result.details.totalWords.expected}, ${this.t("got")} ${result.details.totalWords.actual}` 
                });
                details.createEl("div", { 
                    text: `${this.t("uniqueWords")}: ${this.t("expected")} ${result.details.uniqueWords.expected}, ${this.t("got")} ${result.details.uniqueWords.actual}` 
                });
            }
            
            if (result.error) {
                const errorEl = resultEl.createEl("div", { cls: "test-error" });
                errorEl.setText(`${this.t("error")}: ${result.error}`);
            }
        });

        // Verdict
        const verdictEl = content.createEl("div", { 
            cls: "test-verdict" 
        });
        
        if (results.successRate >= 95) {
            verdictEl.setText("üéâ " + this.t("excellent_result"));
            verdictEl.addClass("test-excellent");
        } else if (results.successRate >= 80) {
            verdictEl.setText("‚ö†Ô∏è  " + this.t("acceptable_result"));
            verdictEl.addClass("test-acceptable");
        } else {
            verdictEl.setText("üö® " + this.t("critical_result"));
            verdictEl.addClass("test-critical");
        }

        const buttonContainer = content.createEl("div", { 
            cls: "modal-button-container" 
        });
        
        buttonContainer.createEl("button", {
            text: this.t("close"),
            cls: "mod-cta"
        }).addEventListener("click", () => modal.close());
        
        modal.open();
    }
};

// Add missing translations
Object.keys(TRANSLATIONS).forEach(lang => {
    TRANSLATIONS[lang] = {
        ...TRANSLATIONS[lang],
        remove: lang === 'russian' ? '—É–¥–∞–ª–µ–Ω–æ' : lang === 'english' ? 'removed' : 'Â∑≤Âà†Èô§',
        close: lang === 'russian' ? '–ó–∞–∫—Ä—ã—Ç—å' : lang === 'english' ? 'Close' : 'ÂÖ≥Èó≠',
        overall: lang === 'russian' ? '–û–±—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç' : lang === 'english' ? 'Overall' : 'ÊÄª‰ΩìÁªìÊûú',
        passed: lang === 'russian' ? '–ø—Ä–æ–π–¥–µ–Ω–æ' : lang === 'english' ? 'passed' : 'ÈÄöËøá',
        expected: lang === 'russian' ? '–æ–∂–∏–¥–∞–ª–æ—Å—å' : lang === 'english' ? 'expected' : 'È¢ÑÊúü',
        got: lang === 'russian' ? '–ø–æ–ª—É—á–µ–Ω–æ' : lang === 'english' ? 'got' : 'ÂæóÂà∞',
        error: lang === 'russian' ? '–û—à–∏–±–∫–∞' : lang === 'english' ? 'Error' : 'ÈîôËØØ',
        status: lang === 'russian' ? '–°—Ç–∞—Ç—É—Å' : lang === 'english' ? 'Status' : 'Áä∂ÊÄÅ',
        entries: lang === 'russian' ? '–ó–∞–ø–∏—Å–µ–π' : lang === 'english' ? 'Entries' : 'Êù°ÁõÆ',
        description: lang === 'russian' ? '–û–ø–∏—Å–∞–Ω–∏–µ' : lang === 'english' ? 'Description' : 'ÊèèËø∞',
        excellent_result: lang === 'russian' ? '–û–¢–õ–ò–ß–ù–û: –õ–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –∏–¥–µ–∞–ª—å–Ω–æ!' : 
                         lang === 'english' ? 'EXCELLENT: Lemmatization is working perfectly!' : 
                         '‰ºòÁßÄÔºöËØçÂΩ¢ËøòÂéüÂ∑•‰ΩúÂÆåÁæéÔºÅ',
        acceptable_result: lang === 'russian' ? '–ü–†–ò–ï–ú–õ–ï–ú–û: –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ' :
                          lang === 'english' ? 'ACCEPTABLE: Some features may not work correctly' :
                          'ÂèØÊé•ÂèóÔºöÊüê‰∫õÂäüËÉΩÂèØËÉΩÊó†Ê≥ïÊ≠£Â∏∏Â∑•‰Ωú',
        critical_result: lang === 'russian' ? '–ö–†–ò–¢–ò–ß–ï–°–ö–ò: –õ–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è —Å–ª–æ–º–∞–Ω–∞!' :
                        lang === 'english' ? 'CRITICAL: Lemmatization is broken!' :
                        '‰∏•ÈáçÔºöËØçÂΩ¢ËøòÂéüÂ∑≤ÊçüÂùèÔºÅ'
    };
});

var word_stats_default = WordStatsPlugin;

module.exports = word_stats_default;